<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content="王者自由,Kingfree,原田莓莓,咲衣憧"><meta name="author" content="原田莓莓,undefined"><meta name="copyright" content="原田莓莓"><title>舍其旧而新是谋 | 原田莓莓</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.2"><script>var GLOBAL = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  localSearch: undefined
} </script><meta name="generator" content="Hexo 5.3.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/favicon.ico"></div><div class="author-info__name text-center">原田莓莓</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">73</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">34</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">10</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接</div><a class="author-info-links__name text-center" href="https://www.byvoid.com" target="_blank">BYVoid</a><a class="author-info-links__name text-center" href="https://zr.is/" target="_blank">Zeyi Fan</a></div></div></div><nav class="/images/background/shinohayu1920.jpg" id="nav" style="background-image: url(/images/background/shinohayu1920.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">原田莓莓</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">首页</a><a class="site-page" href="/archives">博文</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/about">关于</a></span></div><div id="site-info"><div id="site-title">原田莓莓</div><div id="site-sub-title">舍其旧而新是谋</div><div id="site-social-icons"> <a class="social-icon" href="http://weibo.com/kingfree" target="_blank"><i class="fa fa-weibo"></i></a><a class="social-icon" href="https://twitter.com/kingfreet" target="_blank"><i class="fa fa-twitter"></i></a><a class="social-icon" href="https://github.com/kingfree" target="_blank"><i class="fa fa-github"></i></a><a class="social-icon" href="http://git.kingfree.moe" target="_blank"><i class="fa fa-gitlab"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item"><a class="article-title" href="/web-full-stack-engineer/">初步解决全栈痛点——读&quot;《Web 全栈工程师的自我修养》&quot;</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-11-06</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%AE%80%E6%9B%B8%E7%AD%86%E8%A8%98/">讀書筆記</a></span><div class="content"><p>看前言觉得是很哗众取宠的书，再看到这货翻译过《众妙之门》，就不那么抵触了。</p>
<p>我在公司的很长一段时间，都被当成当成“全栈工程师”去分配工作的。甚至一度让我写“Web 全栈工程师”的招聘需求，说实话真觉得有些力不从心。什么是全栈工程师？我认为这个头衔对于个人的能力要求还是很高的，至少我现在还达不到。</p>
<p>其实也没什么难解释的，对于 Web 开发来说，由于 Node.js 的出现，使得掌握了 JavaScript 的前端工程师也可以开始写后端逻辑了，而且 Node.js 自带的高性能服务器也不用再学习什么服务器配置——“Web 全栈工程师”就这么诞生了。</p>
<p>不过在这之前，LAMP 的技术流，代表着上个时代的“Web 全栈”技术，也是不可忽略的。我正是 LAMP 时代成长起来的，甚至到了现在的 Node 时代，会有些跟不上的感觉。</p>
<p>这本书讲得很现实，虽然各方面都讲得比较浅。首先，就算是作为一个全栈工程师，也要有拿得出手的专业技能。如何成为全栈工程师，余果提出了三点：</p>
<ol>
<li><strong>先精后广、一专多长</strong>。这个我非常认同，我现在很缺乏的可能也就是这个。虽然各方面多少都会一点，不过说到那个方面最好，经常会一时语塞。仔细思考下来，虽然兴趣很多，但各个不精，还是应该有所专长。还要注意，专长不是运用某个工具的专长，它不是炫技。</li>
<li><strong>围绕商业目标</strong>。很容易理解，现在流行什么，就要会做什么，不然你怎么创业？或者说怎么好找工作？</li>
<li><strong>关注用户体验</strong>。我是很注重用户体验的，当然用户只是我自己罢了——当然至少要做到这一点吧，虽然在工作中很容易迷失自我。</li>
</ol>
<p>关于学业和实习，我只能说，我已经没有这些机会了，虽然很羡慕优秀大学毕业的学子，但无可奈何，只能凭自己努力了。</p>
<p>关于大公司或创业公司，《软技能》里面说过了，要看自己的目标。我现在的状态虽然不是很好，但进入创业公司的原因只是因为公司主动找上门来了并且待遇还不错，与自己的理想说实话并不是特别相符。</p>
<p>书里也提到了<strong>作品集</strong>，其实对于程序员来说，无非就是博客和 GitHub。这一年来的工作，使得我的代码都托管在了自己的私有平台上没有开源，导致 GitHub 变得一片空白。我觉得还是应该每天利用一些时间编写一些开源代码。博客也很久没更新了，还是应该坚持写。脱离文字很久的现象就是，本身文字水平还不错的我，也很难用文字准确地表现自己的想法了。</p>
<p>HTTP协议、缓存、前端、移动端、CI、设计模式、MVC，这些东西都说的很多次了，没什么新东西。要提的一点是 Git 的分支管理，直接在 master 上修改代码的习惯是不是该改改了？</p>
<p>编程语言的两个极端。我在公开场合都是表示“语言只是工具”的，虽然自己对语言还是很挑的。比如喜欢 Ruby 但讨厌部署，不爱 JavaScript 但是有了 CoffeeScript 的语法糖便会很乐于使用它。</p>
<p>关于设计，我觉得现在很缺乏的是设计的基础知识，脑中有想法但是表现不出来，还要学习。</p>
<p>余果的这本书还是太浅了，很多地方不够深入。好在它能让你知道当前的一些痛点，深入的话就要别的书来支持了。每章后面的延伸阅读可以放到当当购物车，等下一次活动的时候买买买了~</p>
</div><hr></div><div class="recent-post-item"><a class="article-title" href="/how-to-read-a-book/">《如何阅读一本书》</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-10-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%AE%80%E6%9B%B8%E7%AD%86%E8%A8%98/">讀書筆記</a></span><div class="content"><p>译者郝明义在译序中对这本书发表了这样的感慨：</p>
<ol>
<li>羞耻。</li>
<li>何其有幸。</li>
</ol>
<p>我读完此书后，也产生了相似的感情，就是一种<em>相见恨晚</em>。这本书提出的阅读和阅读教育，实际上在我们的义务教育中已经实现了。可是，由于我们对所谓“应试教育”的批判，和对体系的反抗，我们没能够在最好的年龄里认识到我们<em>语文</em>学习的重要性。如果一个人能够在中学时代读到这本书，并按照书中的方法进行训练和进行更多的阅读，那他一定会有所成就。</p>
<p>我现在读到这本书时已经22岁了，失去了最有效的时期——理解力和学习能力大幅下降，忙碌于工作和生计而无暇阅读。不过，这本书的价值还在于，在什么时候遇到它——前提是你读完了，都会成为人生宝贵的财富。当然，这本书不是得道的终点，而只是指引人生的起点罢了。这时候的“朝闻道”，“夕<em>不</em>可死矣”。</p>
</div><hr></div><div class="recent-post-item"><a class="article-title" href="/minix-3/">《操作系统设计与实现》</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2015-05-24</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%AE%80%E6%9B%B8%E7%AD%86%E8%A8%98/">讀書筆記</a></span><div class="content"><p>这本书是MINIX作者Tanenbaum所著的，这种结合代码实例讲操作系统，易于理解。</p>
<p>上下两册，上册讲解，下册代码，看起来也很舒服。</p>
<h3 id="第一章-引言"><a href="#第一章-引言" class="headerlink" title="第一章 引言"></a>第一章 引言</h3><p>操作系统作为扩展机和资源管理器。</p>
<p>四代计算机和相应的操作系统。</p>
<p>操作系统的概念：进程、文件、命令解释器。</p>
<p>系统调用：进程管理、信号管理、文件管理、目录管理、保护、时间管理。</p>
<p>操作系统结构：整体结构、分层结构、虚拟机、外核、C/S模型。</p>
<h3 id="第二章-进程"><a href="#第二章-进程" class="headerlink" title="第二章 进程"></a>第二章 进程</h3><p>进程模型、进程的创建和终止、进程的层级结构、进程的状态、进程的实现。线程。</p>
<p>进程间通信，包括竞争条件和临界区，忙等待形式的互斥，睡眠和唤醒，信号量。互斥、管程、消息传递。</p>
<p>经典的IPC问题：哲学家进餐问题、读者写者问题。</p>
<p>进程调度：批处理系统、交互式系统、实时系统；线程调度。</p>
<h3 id="第三章-输入-输出系统"><a href="#第三章-输入-输出系统" class="headerlink" title="第三章 输入/输出系统"></a>第三章 输入/输出系统</h3><p>I/O设备、设备控制器、内存映射I/O，中断，直接存储器存取。</p>
<p>中端处理器、设备驱动程序。</p>
<p>死锁：援力、鸵鸟算法、监测和恢复、预防、避免。</p>
<h3 id="第四章-存储管理"><a href="#第四章-存储管理" class="headerlink" title="第四章 存储管理"></a>第四章 存储管理</h3><p>基本存储管理：单道程序存储管理、固定分区的多道程序系统、重定位和存储保护。</p>
<p>交换技术：基于位图、基于链表。</p>
<p>虚拟存储管理：页表，关联存储器，反置页表。</p>
<p>页面置换算法：最优置换法、最近未使用、先进先出、第二次机会、时钟、最近最久未使用。</p>
<p>页式存储管理设计：局部与全局分配策略、页面大小、虚拟存储器接口。</p>
<p>段式存储管理：纯分段、段页式。</p>
<h3 id="第五章-文件系统"><a href="#第五章-文件系统" class="headerlink" title="第五章 文件系统"></a>第五章 文件系统</h3></div><hr></div><div class="recent-post-item"><a class="article-title" href="/ps-on-mac/">Photoshop CC 2014 在 Mac 不能使用滤镜库的解决办法</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2015-05-18</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Photoshop/">Photoshop</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Mac/">Mac</a></span><div class="content"><p>近日发现10.10下ps cc的滤镜库不能使用，论坛有人说英文版ps可以正常使用，经实践证明可行。无需语言包，定位到</p>
<pre><code>Adobe Photoshop CC 2014\Locales\zh_CN\Support Files
</code></pre>
<p>把<code>tw10428.dat</code>这个文件删除（记得保留备份），再启动ps就变英文了，可正常使用滤镜库。
要变回中文只要把<code>tw10428.dat</code>这个文件放回原处就行了。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol>
<li><a target="_blank" rel="noopener" href="http://www.macx.cn/thread-2146600-1-1.html">2014cc ps 不能用滤镜库，有没有解决方法！</a></li>
</ol>
</div><hr></div><div class="recent-post-item"><a class="article-title" href="/osask/">《30天自制操作系统》</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2015-04-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%AE%80%E6%9B%B8%E7%AD%86%E8%A8%98/">讀書筆記</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/C/">C</a></span><div class="content"><p>书上讲得很细了，我就说说我在制作过程中和书中不一样的做法。</p>
<h3 id="第1天-4月20日"><a href="#第1天-4月20日" class="headerlink" title="第1天 4月20日"></a>第1天 4月20日</h3><p>写机器码，用的是书中的<a target="_blank" rel="noopener" href="http://www.vcraft.jp/soft/bz.html">Bz编辑器</a>，还是蛮好用的。</p>
<p>写汇编，因为有了<a href="/cs-app/">CS:APP</a>的基础，对于这个自定义的NASK汇编也能很快理解。</p>
<h3 id="第2天-4月21日"><a href="#第2天-4月21日" class="headerlink" title="第2天 4月21日"></a>第2天 4月21日</h3><p>做启动程序，写了个Makefile。</p>
<h3 id="第3天-4月22日"><a href="#第3天-4月22日" class="headerlink" title="第3天 4月22日"></a>第3天 4月22日</h3><p>把程序分离开做IPL。读入前几个柱面之后进入32位模式，就可以使用C语言了。这个启动信息的结构体我定义了一个<code>bootinfo_t</code>类型来简写，而且以后的结构体都这样简写。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BOOTINFO</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> cyls, leds, vmode, reserve;</span><br><span class="line">    <span class="keyword">short</span> scrnx, scrny;</span><br><span class="line">    <span class="keyword">char</span> *vram;</span><br><span class="line">&#125; <span class="keyword">bootinfo_t</span>;</span><br></pre></td></tr></table></figure>
<h3 id="第4天-4月23日"><a href="#第4天-4月23日" class="headerlink" title="第4天 4月23日"></a>第4天 4月23日</h3><p>加载到图形模式就变得有意思了，首先是颜色，书中给出的16色实在不好看，我就用了编程中常用的<a target="_blank" rel="noopener" href="http://ethanschoonover.com/solarized">Solarized配色方案</a>。到画任务栏的时候，我采取了现在比较流行的扁平化界面。为了画Windows徽标，我又将红黄蓝绿这四个颜色做了微调，于是我们就能看到这个漂亮的四色视窗图标了。另外，黑白两色复原。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> base03   0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> base02   1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> base01   2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> base00   3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> base0    4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> base1    5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> base2    6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> base3    7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> yellow   8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> orange   9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> red     10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> magenta 11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> violet  12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> blue    13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cyan    14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> green   15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> table_rgb[<span class="number">16</span> * <span class="number">3</span>] = &#123;</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="comment">/* base03 */</span></span><br><span class="line">    <span class="number">0x07</span>, <span class="number">0x36</span>, <span class="number">0x42</span>, <span class="comment">/* base02 */</span></span><br><span class="line">    <span class="number">0x58</span>, <span class="number">0x6e</span>, <span class="number">0x75</span>, <span class="comment">/* base01 */</span></span><br><span class="line">    <span class="number">0x65</span>, <span class="number">0x7b</span>, <span class="number">0x83</span>, <span class="comment">/* base00 */</span></span><br><span class="line">    <span class="number">0x83</span>, <span class="number">0x94</span>, <span class="number">0x96</span>, <span class="comment">/* base0 */</span></span><br><span class="line">    <span class="number">0x93</span>, <span class="number">0xa1</span>, <span class="number">0xa1</span>, <span class="comment">/* base1 */</span></span><br><span class="line">    <span class="number">0xee</span>, <span class="number">0xe8</span>, <span class="number">0xd5</span>, <span class="comment">/* base2 */</span></span><br><span class="line">    <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="comment">/* base3 */</span></span><br><span class="line">    <span class="number">0xfd</span>, <span class="number">0xb8</span>, <span class="number">0x13</span>, <span class="comment">/* yellow */</span></span><br><span class="line">    <span class="number">0xcb</span>, <span class="number">0x4b</span>, <span class="number">0x16</span>, <span class="comment">/* orange */</span></span><br><span class="line">    <span class="number">0xef</span>, <span class="number">0x50</span>, <span class="number">0x26</span>, <span class="comment">/* red */</span></span><br><span class="line">    <span class="number">0xd3</span>, <span class="number">0x36</span>, <span class="number">0x82</span>, <span class="comment">/* magenta */</span></span><br><span class="line">    <span class="number">0x6c</span>, <span class="number">0x71</span>, <span class="number">0xc4</span>, <span class="comment">/* violet */</span></span><br><span class="line">    <span class="number">0x23</span>, <span class="number">0x99</span>, <span class="number">0xd7</span>, <span class="comment">/* blue */</span></span><br><span class="line">    <span class="number">0x2a</span>, <span class="number">0xa1</span>, <span class="number">0x98</span>, <span class="comment">/* cyan */</span></span><br><span class="line">    <span class="number">0x7f</span>, <span class="number">0xbc</span>, <span class="number">0x43</span>, <span class="comment">/* green */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/images/osask/day04_taskbar.png" alt="任务栏"></p>
<h3 id="第5天-4月24日"><a href="#第5天-4月24日" class="headerlink" title="第5天 4月24日"></a>第5天 4月24日</h3><p>今天更有意思了，在屏幕上显示鼠标指针和字体。一直以来都觉得书里面给出的指针太难看，就仔细分析了一下Windows 8的鼠标指针形状，将其描绘了出来。注意到这个鼠标指针是19×12大小的，要做相应修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CURSOR_X     12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CURSOR_Y     19</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> cursor[CURSOR_Y][CURSOR_X] = &#123;</span><br><span class="line">    <span class="string">&quot;*           &quot;</span>,</span><br><span class="line">    <span class="string">&quot;**          &quot;</span>,</span><br><span class="line">    <span class="string">&quot;*O*         &quot;</span>,</span><br><span class="line">    <span class="string">&quot;*OO*        &quot;</span>,</span><br><span class="line">    <span class="string">&quot;*OOO*       &quot;</span>,</span><br><span class="line">    <span class="string">&quot;*OOOO*      &quot;</span>,</span><br><span class="line">    <span class="string">&quot;*OOOOO*     &quot;</span>,</span><br><span class="line">    <span class="string">&quot;*OOOOOO*    &quot;</span>,</span><br><span class="line">    <span class="string">&quot;*OOOOOOO*   &quot;</span>,</span><br><span class="line">    <span class="string">&quot;*OOOOOOOO*  &quot;</span>,</span><br><span class="line">    <span class="string">&quot;*OOOOOOOOO* &quot;</span>,</span><br><span class="line">    <span class="string">&quot;*OOOOOOOOOO*&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*OOOOOO*****&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*OOO*OO*    &quot;</span>,</span><br><span class="line">    <span class="string">&quot;*OO* *OO*   &quot;</span>,</span><br><span class="line">    <span class="string">&quot;*O*  *OO*   &quot;</span>,</span><br><span class="line">    <span class="string">&quot;**    *OO*  &quot;</span>,</span><br><span class="line">    <span class="string">&quot;      *OO*  &quot;</span>,</span><br><span class="line">    <span class="string">&quot;       **   &quot;</span></span><br><span class="line">&#125;; <span class="comment">/* 仿 Window 8 的鼠标指针 */</span></span><br></pre></td></tr></table></figure>
<p>这个鼠标指针我觉得还是蛮好看的，虽然在虚拟机里放大了有很明显的锯齿。</p>
<p>关于字体，先开始我直接用了书中给出的字体，这个字体又大又丑（16px），虽然因为懒不想动了但实在是忍不住，上网找个了好看点的点阵字体：<a target="_blank" rel="noopener" href="https://code.google.com/p/zpix">最像素EX2</a>（12px）。这个字体不仅好看，而且包含中日字符，虽然暂时用不到，但是有了一劳永逸的感觉。用FontForge打开这个字体，另外生成一个基于ASCII编码表的Windows FNT字体。算一下，一个字符12px，每行用一个字节表述，就是12字节；一共256个字符，就是256×12=3456字节。可是看了看这个<code>ZpixEX2-12.fnt</code>文件是3529字节，多出了73字节，直接载入运行的话果然乱码了。用Bz打开看看，发现头部有一些字体描述信息，所以我尝试找这个偏移量。经过多次试错和计算，终于算出来这个偏移量是45×16=726字符（这里还有问题，在45(0x2D)处实际上是<code>de.google.com/p/zpix</code>这个字符串，剩下的二进制数据意义不明。已知用FontForge打开这个文件可以看到在0x20之前没有数据。另外，0x7f-0x9f也没有字形数据，后面的估计也会出错。不过这里我们只用到0x20-0x7e之间的普通字符，暂时还好。），定义成常量。另外也要注意，因为这里变成了12px的字体，所以相应的行高和字宽都要做更改，同样定义成常量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FNT_H        12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FNT_W         6  <span class="comment">// FNT_H / 2</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FNT_OFFSET  726  <span class="comment">// 65 + 55 * FNT_H + 1</span></span></span><br></pre></td></tr></table></figure>
<p>效果还不错，左边的是书中的Haribote-OS ，右边的是我们的。既然看起来还不错，我给它起个名字叫霹雳啪啦操作系统吧（笑）。</p>
<p><img src="/images/osask/day05_1osask.png" alt="书中的例子">
<img src="/images/osask/day05_2font.png" alt="指针和字体"></p>
<h3 id="第6天-4月24日"><a href="#第6天-4月24日" class="headerlink" title="第6天 4月24日"></a>第6天 4月24日</h3><p>鼠标不能动，很不爽，于是强行往下做了一天。我们用C语言混着汇编，定义了三个中断的捕获函数。不过只捕获到了键盘中断，鼠标还是没反应。</p>
<p><img src="/images/osask/day06_int21.png" alt="键盘中断"></p>
<h3 id="第7天-4月25日"><a href="#第7天-4月25日" class="headerlink" title="第7天 4月25日"></a>第7天 4月25日</h3><p>使用一个FIFO队列缓冲区来获取按键编码，然后我们就可以获取3字节的鼠标数据了。</p>
<h3 id="第8天-4月25日"><a href="#第8天-4月25日" class="headerlink" title="第8天 4月25日"></a>第8天 4月25日</h3><p>获取鼠标数据后，解析出来移动位置，就可以在屏幕上移动鼠标了。鼠标能动了当然是很高兴，不过明显这个移动逻辑太单纯，以至于把我们可爱的任务栏都擦除了。</p>
<p><img src="/images/osask/day08_pointer1.png" alt="鼠标移动">
<img src="/images/osask/day08_pointer2.png" alt="鼠标移动"></p>
<p>然后终于把汇编部分讲明白了。</p>
<h3 id="第9天-4月26日"><a href="#第9天-4月26日" class="headerlink" title="第9天 4月26日"></a>第9天 4月26日</h3><p>检查内存容量，在此基础上实现了一个简单的内存管理，通过管理空闲内存块来分配和释放内存。</p>
<h3 id="第10天-4月26日"><a href="#第10天-4月26日" class="headerlink" title="第10天 4月26日"></a>第10天 4月26日</h3><p>实现了图层，这样我们的鼠标就可以穿过任务栏而不至于破坏它了。一个小的改动，把<code>sheet_t</code>结构体的透明色标识符改成了<code>alpha</code>。</p>
<p><img src="/images/osask/day10_sheet.png" alt="图层"></p>
<h3 id="第11天-4月26日"><a href="#第11天-4月26日" class="headerlink" title="第11天 4月26日"></a>第11天 4月26日</h3><p>绘制了一个窗口，刚开始我想弄成Windows 8那样的，不过我发现它的边框太大了，就做了一些修改。同样的，关闭按钮也不合适，改。还有窗口标题要居中。嗯，看看这个计数器窗口，是不是有点像Windows 10了。</p>
<p><img src="/images/osask/day11_window1.png" alt="窗口">
<img src="/images/osask/day11_window2.png" alt="计数器窗口"></p>
<p>这里的“PriPara = Prism Paradise”刚从桌面上了窗口就要说拜拜了，プリパラ=プリティーリズムパラダイス，这就是霹雳啪啦的意思咯。</p>
<h3 id="第12天-4月27日"><a href="#第12天-4月27日" class="headerlink" title="第12天 4月27日"></a>第12天 4月27日</h3><p>设置多个定时器，计量时间等。主要优化了中断的处理。</p>
<h3 id="第13天-4月28日"><a href="#第13天-4月28日" class="headerlink" title="第13天 4月28日"></a>第13天 4月28日</h3><p>继续优化定时器，将队列缓冲区扩展到32位，用链表来加快中断处理。</p>
<h3 id="第14天-4月28日"><a href="#第14天-4月28日" class="headerlink" title="第14天 4月28日"></a>第14天 4月28日</h3><p>我们又在图形界面上取得了重大进展，这是最令人振奋的。首先使用了VBE提高了屏幕分辨率。然后我们捕获了键盘输入，显示在屏幕上，还画了个漂亮的文本框和光标（当然还是仿Windows 8的）。最后，窗口也能移动了，真是太开心了。</p>
<p><img src="/images/osask/day14_type.png" alt="大分辨率"></p>
<h3 id="第15天-4月29日"><a href="#第15天-4月29日" class="headerlink" title="第15天 4月29日"></a>第15天 4月29日</h3><p>今天我们加入了多任务，就是时间片分割，保存上下文。</p>
<p>测试速度：QEMU约是4百万，VirtualBox约是4千万。</p>
<h3 id="第16天-4月30日"><a href="#第16天-4月30日" class="headerlink" title="第16天 4月30日"></a>第16天 4月30日</h3><p>实现了任务管理自动化、任务休眠，并且设定了任务优先级和优先层。</p>
<p>测试速度：QEMU约是8百万，VirtualBox约是7千万。提高了一倍。</p>
<p><img src="/images/osask/day16_mtask.png" alt="大分辨率"></p>
<h3 id="第17天-5月1日"><a href="#第17天-5月1日" class="headerlink" title="第17天 5月1日"></a>第17天 5月1日</h3><p>创建了命令行窗口，实现了字符输入，包括大小写字母和符号、锁定键。</p>
<p><img src="/images/osask/day17_terminal.png" alt="大分辨率"></p>
<h3 id="第18天-5月1日"><a href="#第18天-5月1日" class="headerlink" title="第18天 5月1日"></a>第18天 5月1日</h3><p>修正了光标闪烁，实现了回车换行和滚屏。</p>
<p>实现了显示内存大小的<code>mem</code>，显示目录内容的<code>dir</code>命令（别名<code>ls -l</code>）、清屏的<code>cls</code>命令（别名<code>clear</code>）。</p>
<h3 id="第19天-5月2日"><a href="#第19天-5月2日" class="headerlink" title="第19天 5月2日"></a>第19天 5月2日</h3><p>实现了显示文件内容的<code>type</code>（别名<code>cat</code>）命令，并支持FAT12文件系统。</p>
<p>这里我把命令行窗口改得更大了，便于显示更多内容。其实现使用了大量常量（改掉了原来的Magic Number）。</p>
<h3 id="第20天-5月3日"><a href="#第20天-5月3日" class="headerlink" title="第20天 5月3日"></a>第20天 5月3日</h3><p>开始编写应用程序，实现了显示字符和显示字符串的API。</p>
<p><img src="/images/osask/day21_terminal.png" alt="大分辨率"></p>
<h3 id="第21天-5月6日"><a href="#第21天-5月6日" class="headerlink" title="第21天 5月6日"></a>第21天 5月6日</h3><p>可以用C编写应用程序了。支持异常。</p>
<h3 id="第22天-5月7日"><a href="#第22天-5月7日" class="headerlink" title="第22天 5月7日"></a>第22天 5月7日</h3><p><code>Ctrl+C</code>强制结束任务。系统API的增加。</p>
<h3 id="第23天-5月10日"><a href="#第23天-5月10日" class="headerlink" title="第23天 5月10日"></a>第23天 5月10日</h3><p>malloc的实现。</p>
<p>显示窗口和关闭窗口。</p>
<h3 id="第24天-5月13日"><a href="#第24天-5月13日" class="headerlink" title="第24天 5月13日"></a>第24天 5月13日</h3><p>使用鼠标切换、移动和关闭窗口。</p>
<h3 id="第25天-5月14日"><a href="#第25天-5月14日" class="headerlink" title="第25天 5月14日"></a>第25天 5月14日</h3><p>256色。</p>
<h3 id="第26天-5月16日-5月19日"><a href="#第26天-5月16日-5月19日" class="headerlink" title="第26天 5月16日~5月19日"></a>第26天 5月16日~5月19日</h3><p>多任务内存分配和强制结束。</p>
<p>多个终端和关闭终端。</p>
<p><code>open</code>和<code>start</code>启动任务。</p>
<h3 id="第27天-5月23日"><a href="#第27天-5月23日" class="headerlink" title="第27天 5月23日"></a>第27天 5月23日</h3><p>整理目录结构。分拆API。使用局部段描述符保护程序。</p>
<h3 id="第28天-5月24日"><a href="#第28天-5月24日" class="headerlink" title="第28天 5月24日"></a>第28天 5月24日</h3><p>alloca的实现和局部大变量。</p>
<p>并不成功地汉字显示——至今没有解决和正在解决……目前是使用了Unifont的16点阵字体，编码使用UTF-8解析。</p>
</div><hr></div><div class="recent-post-item"><a class="article-title" href="/talk-about-open-sourse-licenses/">浅谈开源协议</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2015-03-20</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%BC%80%E6%BA%90/">开源</a></span><div class="content"><p>首先，开源和自由是不一样的。开源不等于自由，开源的软件并不意味着你能够<strong>自由</strong>使用或修改之，你要受到各种开源协议的限制。</p>
<p><strong>开源协议</strong>，虽然有时可以与<strong>自由软件许可证</strong>一词互相替换，但注意这两者并不完全一致。在一定程度上，自由软件包含开源软件，而开源软件并不一定是自由软件。</p>
<p>常见的开源协议包括 GNU 系的 <a target="_blank" rel="noopener" href="http://www.gnu.org/licenses/gpl.html">GPL</a> 和 <a target="_blank" rel="noopener" href="http://www.gnu.org/copyleft/lesser.html">LGPL</a>、火狐 Mozilla 的 <a target="_blank" rel="noopener" href="http://www.mozilla.org/MPL/">MPL</a>、<a target="_blank" rel="noopener" href="http://www.apache.org/licenses/LICENSE-2.0">Apache</a>、<a target="_blank" rel="noopener" href="http://opensource.org/licenses/BSD-3-Clause">BSD</a>、<a target="_blank" rel="noopener" href="http://opensource.org/licenses/MIT">MIT</a>。</p>
<h2 id="MIT"><a href="#MIT" class="headerlink" title="MIT"></a>MIT</h2><p>MIT 来自麻省理工学院，是限制非常宽泛的协议。你只需要在你的发行版中包含原许可协议的声明即可，无论你发布源代码还是二进制文件。</p>
<h2 id="BSD"><a href="#BSD" class="headerlink" title="BSD"></a>BSD</h2><p>BSD 来自加州大学伯克利分校，也是 BSD 系操作系统所采用的协议。比 MIT 限制多一点，要求在源代码和文档声明中包含原来的协议，不可使用原作者的名称做市场推广。</p>
<p>我个人比较喜欢宽松的协议，比如我会使用 BSD 协议（三句版），中文翻译如下：</p>
<pre><code>版权所有 (c) &lt;年份&gt;, &lt;拥有者&gt;
保留所有权利。

这份授权条款，在使用者符合以下三条件情形下，授予使用者使用及再散播本
软件包装原始码及二进制可执行形式的权利，无论此包装是否经改作皆然：

* 对于本软件源代码的再散播，必须保留上述的版权宣告、此三条件表列，以及
  下述的免责声明。
* 对于本套件二进制可执行形式的再散播，必须连带以文件或其他附于散播包装
  中的媒介方式，重制上述之版权宣告、此三条件表列，以及下述的免责声明。
* 未获事前取得书面许可，不得使用版权拥有者及其贡献者之名称，来为本软
  件之衍生物做任何表示支持、认可或推广、促销之行为。

免责声明：本软件是由版权拥有者及其贡献者以现状提供，本软件包装不负任何
明示或默示之担保责任，包括但不限于就适售性以及特定目的的适用性为默示性
担保。作者及本软件之贡献者，无论任何条件、无论成因或任何责任主义、无论
此责任为因合约关系、无过失责任主义或因非违约之侵权（包括过失或其他原因
等）而起，对于任何因使用本软件包装所产生的任何直接性、间接性、偶发性、
特殊性、惩罚性或任何结果的损害（包括但不限于替代商品或劳务之购用、使用
损失、资料损失、利益损失、业务中断等等），不负任何责任，即在该种使用已
获事前告知可能会造成此类损害的情形下亦然。
</code></pre>
<h2 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h2><p>Apache 会稍微麻烦一点，要求在每个改动的源文件中都声明该协议。但它是商业友好的，允许再发布为商业软件。</p>
<h2 id="Mozilla"><a href="#Mozilla" class="headerlink" title="Mozilla"></a>Mozilla</h2><p>MPL 是火狐浏览器所采用的协议。它允许与其它许可证混合使用，但不允许派生作品完全转化为私有。</p>
<h2 id="LGPL"><a href="#LGPL" class="headerlink" title="LGPL"></a>LGPL</h2><p>LGPL 是较为宽松的 GPL 协议，它拥有和 GPL 相同的特性，区别在于 LGPL 在使用类库时并不需要发布源代码和继承原协议，较为商业友好。</p>
<h2 id="GPL"><a href="#GPL" class="headerlink" title="GPL"></a>GPL</h2><p>GPL 是 GNU 的招牌，非常严格，拥有非常强的传染性。只要软件中使用了 GPL 的东西，这个软件必须以 GPL 发布，必须开放源代码，不可私有化或商业化。</p>
<p>除了软件的开源协议，还有用于文档的自由文档协议。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol>
<li><a target="_blank" rel="noopener" href="http://www.awflasher.com/blog/archives/939">五种开源协议的比较</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html">如何选择开源许可证？</a></li>
<li><a target="_blank" rel="noopener" href="http://www.gnu.org/licenses/license-list.html">Various Licenses and Comments about Them</a></li>
<li><a target="_blank" rel="noopener" href="http://opensource.org/licenses/alphabetical">Licenses by Name</a></li>
<li><a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E8%BD%AF%E4%BB%B6">自由软件 - 维基百科</a></li>
</ol>
</div><hr></div><div class="recent-post-item"><a class="article-title" href="/cs-app/">《深入理解计算机系统》</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2015-03-12</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%AE%80%E6%9B%B8%E7%AD%86%E8%A8%98/">讀書筆記</a></span><div class="content"><h2 id="第1章-计算机系统漫游"><a href="#第1章-计算机系统漫游" class="headerlink" title="第1章 计算机系统漫游"></a>第1章 计算机系统漫游</h2><p>信息就是 位+上下文。</p>
<p>程序编译的四个阶段：预处理阶段 <code>cpp</code>、编译阶段 <code>cc1</code>、汇编阶段 <code>as</code>、链接阶段 <code>ld</code>。</p>
<p>为何要了解编译系统的工作方式：优化程序性能、理解链接时出现的错误、避免安全漏洞。</p>
<p>系统的硬件组成：总线、I/O 设备、主存、处理器。演示了<code>hello</code>程序的运行过程。</p>
<p>三级高速缓存。存储器层次结构的金字塔。</p>
<p>操作系统管理硬件：进程和线程、虚拟存储器、文件。</p>
<p>并发和并行。</p>
<h1 id="第一部分-程序结构和执行"><a href="#第一部分-程序结构和执行" class="headerlink" title="第一部分 程序结构和执行"></a>第一部分 程序结构和执行</h1><h2 id="第2章-信息的表示和处理"><a href="#第2章-信息的表示和处理" class="headerlink" title="第2章 信息的表示和处理"></a>第2章 信息的表示和处理</h2><p>十六进制表示法，十六进制、二进制、十进制之间的转换。</p>
<p>字和字长、大端法和小端法。</p>
<p>布尔代数，位级运算、逻辑运算、移位运算。</p>
<p>整数的表示法：</p>
<ul>
<li><p>无符号整数 $B2U_w(\vec{x})\doteq\sum_{i=0}^{w-1}{x_i2^i}$</p>
</li>
<li><p>补码 $B2T_w(\vec{x})\doteq -x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}{x_i2^i}$</p>
</li>
<li><p>反码、原码</p>
</li>
<li><p>补码转无符号数：
$T2U_w(x)=\left{\begin{array}{ll}x+2^w,&amp; x&lt;0\x,&amp; x\ge 0\end{array}\right.$</p>
</li>
<li><p>无符号数转补码：
$U2T_w(u)=\left{\begin{array}{ll}u,&amp; u&lt;2^{w-1}\x-2^w,&amp; u\ge 2^{w-1}\end{array}\right.$</p>
</li>
</ul>
<p>C 隐式地将有符号参数强制转换为无符号数并假设其非负来进行计算。</p>
<p>数字的扩展：</p>
<ul>
<li>零扩展</li>
<li>符号扩展：$B2T_{w+k}([x_{w-1},\cdots,x_{w-1},x_{w-1},x_{w-2},\cdots,x_0])=B2T_{w}([x_{w-1},x_{w-2},\cdots,x_0])$</li>
</ul>
<p>数的截断：</p>
<ul>
<li>无符号数的截断：$$B2U_k([x_{k-1},x_{k-2},\cdots,x_0])=B2U_{w}([x_{w-1},x_{w-2},\cdots,x_0])\mod {2^k}$$</li>
<li>有符号数的截断：$$B2T_k([x_{k-1},x_{k-2},\cdots,x_0])=U2T_k(B2U_{w}([x_{w-1},x_{w-2},\cdots,x_0])\mod {2^k})$$</li>
</ul>
<p>整数的运算：</p>
<ul>
<li>无符号加法：$x+^u_w y=\left{\begin{array}{ll}x+y,&amp; x+y&lt;2^w\x+y-2^w,&amp; 2^w\le x+y&lt;2^{w+1}\end{array}\right.$</li>
<li>补码加法：$$x+^t_w y=U2T_w[(x+y)\mod {2^w}]=\left{\begin{array}{lll}
x+y-2^w,&amp; 2^{w-1}\le x+y, &amp; \text{正溢出}\
x+y,&amp; -2^{w-1}\le x+y&lt;2^{w-1},&amp; \text{正常}\
x+y+2^w,&amp; x+y&lt;-2^{w-1}, &amp; \text{负溢出}
\end{array}\right.$$</li>
<li>补码的非：$-^t_w x=\left{\begin{array}{ll}-2^{w-1},&amp; x=-2^{w-1}\-x,&amp; x&gt;-2^{w-1}\end{array}\right.$</li>
<li>无符号乘法：$x*^u_w y=(x\cdot y)\mod {2^w}$</li>
<li>补码乘法：$x*^t_w y=U2T_w((x\cdot y)\mod {2^w})$</li>
<li>乘以常数：$B2U_{w+k}([x_{w-1},x_{w-2},\cdots,x_0,0,\cdots,0])=x2^k$</li>
<li>除以2的幂：$x/2^k=$<code>(x &lt; 0 ? (x + (1 &lt;&lt; k) - 1) : x) &gt;&gt; k</code></li>
</ul>
<p>浮点数：</p>
<ul>
<li>二进制小数（定点小数）</li>
<li>IEEE 浮点小数：规格化的值、非规格化的值、无穷大、NaN。</li>
<li>舍入</li>
<li>浮点运算</li>
</ul>
<h2 id="第3章-程序的机器级表示"><a href="#第3章-程序的机器级表示" class="headerlink" title="第3章 程序的机器级表示"></a>第3章 程序的机器级表示</h2><p>本章主要讲的是 IA32 汇编。在命令行上使用 <code>-S</code> 产生 AT&amp;T 格式的汇编代码：</p>
<pre><code>gcc -O1 -S -m32 &lt;源文件&gt;
</code></pre>
<p>实际的编译代码和书上讲的略有区别，并且不同的优化选项也会产生不同的汇编代码。</p>
<h4 id="整数寄存器"><a href="#整数寄存器" class="headerlink" title="整数寄存器"></a>整数寄存器</h4><table>
<thead>
<tr>
<th>四字寄存器(64位)</th>
<th>双字寄存器(32位)</th>
<th>字寄存器(16位)</th>
<th>高字节寄存器</th>
<th>低字节寄存器</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>63-31</td>
<td>31-15</td>
<td>15-0</td>
<td>15-8</td>
<td>7-0</td>
<td>64位下的作用</td>
</tr>
<tr>
<td>%rax</td>
<td><strong>%eax</strong></td>
<td><strong>%ax</strong></td>
<td><strong>%ah</strong></td>
<td><strong>%al</strong></td>
<td>返回值</td>
</tr>
<tr>
<td>%rbx</td>
<td><strong>%ebx</strong></td>
<td><strong>%bx</strong></td>
<td><strong>%bh</strong></td>
<td><strong>%bl</strong></td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%rcx</td>
<td><strong>%ecx</strong></td>
<td><strong>%cx</strong></td>
<td><strong>%ch</strong></td>
<td><strong>%cl</strong></td>
<td>第4个参数</td>
</tr>
<tr>
<td>%rdx</td>
<td><strong>%edx</strong></td>
<td><strong>%dx</strong></td>
<td><strong>%dh</strong></td>
<td><strong>%dl</strong></td>
<td>第3个参数</td>
</tr>
<tr>
<td>%rsi</td>
<td><strong>%esi</strong></td>
<td><strong>%si</strong></td>
<td></td>
<td>%sil</td>
<td>第2个参数</td>
</tr>
<tr>
<td>%rdi</td>
<td><strong>%edi</strong></td>
<td><strong>%di</strong></td>
<td></td>
<td>%dil</td>
<td>第1个参数</td>
</tr>
<tr>
<td>%rbp</td>
<td><strong>%ebp</strong></td>
<td><strong>%bp</strong></td>
<td></td>
<td>%bpl</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%rsp</td>
<td><strong>%esp</strong></td>
<td><strong>%sp</strong></td>
<td></td>
<td>%spl</td>
<td>栈指针</td>
</tr>
<tr>
<td>%r8</td>
<td>%r8d</td>
<td>%r8w</td>
<td></td>
<td>%r8b</td>
<td>第5个参数</td>
</tr>
<tr>
<td>%r9</td>
<td>%r9d</td>
<td>%r9w</td>
<td></td>
<td>%r9b</td>
<td>第6个参数</td>
</tr>
<tr>
<td>%r10</td>
<td>%r10d</td>
<td>%r10w</td>
<td></td>
<td>%r10b</td>
<td>调用者保存</td>
</tr>
<tr>
<td>%r11</td>
<td>%r11d</td>
<td>%r11w</td>
<td></td>
<td>%r11b</td>
<td>调用者保存</td>
</tr>
<tr>
<td>%r12</td>
<td>%r12d</td>
<td>%r12w</td>
<td></td>
<td>%r12b</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%r13</td>
<td>%r13d</td>
<td>%r13w</td>
<td></td>
<td>%r13b</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%r14</td>
<td>%r14d</td>
<td>%r14w</td>
<td></td>
<td>%r14b</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%r15</td>
<td>%r15d</td>
<td>%r15w</td>
<td></td>
<td>%r15b</td>
<td>被调用者保存</td>
</tr>
</tbody></table>
<h4 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h4><table>
<thead>
<tr>
<th>立即数</th>
<th><code>$Imm</code></th>
<th><code>Imm</code></th>
<th>立即数寻址</th>
</tr>
</thead>
<tbody><tr>
<td>寄存器</td>
<td><code>Ea</code></td>
<td><code>R[Ea]</code></td>
<td>寄存器寻址</td>
</tr>
<tr>
<td>存储器</td>
<td><code>Imm</code></td>
<td><code>M[Imm]</code></td>
<td>绝对寻址</td>
</tr>
<tr>
<td>存储器</td>
<td><code>Imm(Eb,Ei,s)</code></td>
<td><code>M[Imm+R[Eb]+R[Ej]*s]</code></td>
<td>比例变址寻址</td>
</tr>
</tbody></table>
<h4 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h4><table>
<thead>
<tr>
<th><code>CF</code></th>
<th>进位标志</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>ZF</code></td>
<td>零标志</td>
<td></td>
</tr>
<tr>
<td><code>SF</code></td>
<td>符号标志</td>
<td></td>
</tr>
<tr>
<td><code>OF</code></td>
<td>移除标志</td>
<td></td>
</tr>
</tbody></table>
<h4 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h4><table>
<thead>
<tr>
<th>数据传送指令</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>movb S,D</code></td>
<td>传送字节S到D</td>
<td>传送</td>
</tr>
<tr>
<td><code>movw S,D</code></td>
<td>传送字S到D</td>
<td>传送</td>
</tr>
<tr>
<td><code>movl S,D</code></td>
<td>传送双字S到D</td>
<td>传送</td>
</tr>
<tr>
<td><code>movabsq R,I</code></td>
<td>传送立即数I到寄存器R</td>
<td>传送(64位)</td>
</tr>
<tr>
<td><code>movq S,D</code></td>
<td>传送四字S到D</td>
<td>传送(64位)</td>
</tr>
<tr>
<td><code>movsbw S,D</code></td>
<td>传送符号扩展字节S到字D</td>
<td>符号传送</td>
</tr>
<tr>
<td><code>movsbl S,D</code></td>
<td>传送符号扩展字节S到双字D</td>
<td>符号传送</td>
</tr>
<tr>
<td><code>movswl S,D</code></td>
<td>传送符号扩展字S到双字D</td>
<td>符号传送</td>
</tr>
<tr>
<td><code>movsbq S,D</code></td>
<td>传送符号扩展字节S到四字D</td>
<td>符号传送</td>
</tr>
<tr>
<td><code>movswq S,D</code></td>
<td>传送符号扩展字S到四字D</td>
<td>符号传送</td>
</tr>
<tr>
<td><code>movslq S,D</code></td>
<td>传送符号扩展双字S到四字D</td>
<td>符号传送</td>
</tr>
<tr>
<td><code>movzbw S,D</code></td>
<td>传送零扩展字节S到字D</td>
<td>零传送</td>
</tr>
<tr>
<td><code>movzbl S,D</code></td>
<td>传送零扩展字节S到双字D</td>
<td>零传送</td>
</tr>
<tr>
<td><code>movzwl S,D</code></td>
<td>传送零扩展字S到双字D</td>
<td>零传送</td>
</tr>
<tr>
<td><code>movzbq S,D</code></td>
<td>传送零扩展字节S到四字D</td>
<td>零传送(64位)</td>
</tr>
<tr>
<td><code>movzwq S,D</code></td>
<td>传送零扩展字S到四字D</td>
<td>零传送(64位)</td>
</tr>
<tr>
<td><code>movzlq S,D</code></td>
<td>传送零扩展双字S到四字D</td>
<td>零传送(64位)</td>
</tr>
<tr>
<td><code>pushl S</code></td>
<td><code>R[%esp] -= 4;   M[R[%esp]] = S</code></td>
<td>压栈</td>
</tr>
<tr>
<td><code>popl D</code></td>
<td><code>D = M[R[%esp]]; R[%esp] += 4</code></td>
<td>弹栈</td>
</tr>
<tr>
<td><code>pushq S</code></td>
<td><code>R[%rsp] -= 8;   M[R[%rsp]] = S</code></td>
<td>压栈(64位)</td>
</tr>
<tr>
<td><code>popq D</code></td>
<td><code>D = M[R[%rsp]]; R[%rsp] += 8</code></td>
<td>弹栈(64位)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>基本算术操作</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>leal S,D</code></td>
<td><code>D = &amp;S</code></td>
<td>加载有效地址</td>
</tr>
<tr>
<td><code>inc D</code></td>
<td><code>D++</code></td>
<td>递增</td>
</tr>
<tr>
<td><code>dec D</code></td>
<td><code>D--</code></td>
<td>递减</td>
</tr>
<tr>
<td><code>neg D</code></td>
<td><code>D = -D</code></td>
<td>取反</td>
</tr>
<tr>
<td><code>not D</code></td>
<td><code>D = ~D</code></td>
<td>取非</td>
</tr>
<tr>
<td><code>add S,D</code></td>
<td><code>D += S</code></td>
<td>加</td>
</tr>
<tr>
<td><code>sub S,D</code></td>
<td><code>D -= S</code></td>
<td>减</td>
</tr>
<tr>
<td><code>imul S,D</code></td>
<td><code>D *= S</code></td>
<td>乘</td>
</tr>
<tr>
<td><code>xor S,D</code></td>
<td><code>D ^= S</code></td>
<td>异或</td>
</tr>
<tr>
<td><code>or S,D</code></td>
<td><code>D |= S</code></td>
<td>或</td>
</tr>
<tr>
<td><code>and S,D</code></td>
<td><code>D &amp;= S</code></td>
<td>与</td>
</tr>
<tr>
<td><code>sal k,D</code></td>
<td><code>D &lt;&lt;= k</code></td>
<td>左移</td>
</tr>
<tr>
<td><code>shl k,D</code></td>
<td><code>D &lt;&lt;= k</code></td>
<td>左移</td>
</tr>
<tr>
<td><code>sar k,D</code></td>
<td><code>D &gt;&gt;= k</code></td>
<td>算术右移</td>
</tr>
<tr>
<td><code>shr k,D</code></td>
<td><code>D &gt;&gt;&gt;= k</code></td>
<td>逻辑右移</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>特殊算术操作</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>imull S</code></td>
<td><code>R[%edx]:R[%eax] = S * R[%eax]</code></td>
<td>有符号乘法</td>
</tr>
<tr>
<td><code>mull S</code></td>
<td><code>R[%edx]:R[%eax] = S * R[%eax]</code></td>
<td>无符号乘法</td>
</tr>
<tr>
<td><code>cltd</code></td>
<td><code>R[%edx]:R[%eax] = R[%eax]</code></td>
<td>有符号扩展</td>
</tr>
<tr>
<td><code>idivl S</code></td>
<td><code>R[%edx] = R[%edx]:R[%eax] % S</code></td>
<td>有符号除法</td>
</tr>
<tr>
<td></td>
<td><code>R[%eax] = R[%edx]:R[%eax] / S</code></td>
<td></td>
</tr>
<tr>
<td><code>divl S</code></td>
<td><code>R[%edx] = R[%edx]:R[%eax] % S</code></td>
<td>无符号除法</td>
</tr>
<tr>
<td></td>
<td><code>R[%eax] = R[%edx]:R[%eax] / S</code></td>
<td></td>
</tr>
<tr>
<td><code>imulq S</code></td>
<td><code>R[%rdx]:R[%rax] = S * R[%rax]</code></td>
<td>有符号乘法(64位)</td>
</tr>
<tr>
<td><code>mulq S</code></td>
<td><code>R[%rdx]:R[%rax] = S * R[%rax]</code></td>
<td>无符号乘法(64位)</td>
</tr>
<tr>
<td><code>cltdq</code></td>
<td><code>R[%rdx]:R[%rax] = R[%rax]</code></td>
<td>有符号扩展(64位)</td>
</tr>
<tr>
<td><code>idivq S</code></td>
<td><code>R[%rdx] = R[%rdx]:R[%rax] % S</code></td>
<td>有符号除法(64位)</td>
</tr>
<tr>
<td></td>
<td><code>R[%rax] = R[%rdx]:R[%rax] / S</code></td>
<td></td>
</tr>
<tr>
<td><code>divq S</code></td>
<td><code>R[%rdx] = R[%rdx]:R[%rax] % S</code></td>
<td>无符号除法(64位)</td>
</tr>
<tr>
<td></td>
<td><code>R[%rax] = R[%rdx]:R[%rax] / S</code></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>比较和测试指令</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>cmpb S2,S1</code></td>
<td>比较字节 <code>S1 - S2</code></td>
<td>比较</td>
</tr>
<tr>
<td><code>cmpw S2,S1</code></td>
<td>比较单字 <code>S1 - S2</code></td>
<td>比较</td>
</tr>
<tr>
<td><code>cmpl S2,S1</code></td>
<td>比较双字 <code>S1 - S2</code></td>
<td>比较</td>
</tr>
<tr>
<td><code>cmpq S2,S1</code></td>
<td>比较四字 <code>S1 - S2</code></td>
<td>比较(64位)</td>
</tr>
<tr>
<td><code>testb S2,S1</code></td>
<td>测试字节 <code>S1 &amp; S2</code></td>
<td>测试</td>
</tr>
<tr>
<td><code>testw S2,S1</code></td>
<td>测试单字 <code>S1 &amp; S2</code></td>
<td>测试</td>
</tr>
<tr>
<td><code>testl S2,S1</code></td>
<td>测试双字 <code>S1 &amp; S2</code></td>
<td>测试</td>
</tr>
<tr>
<td><code>testq S2,S1</code></td>
<td>测试四字 <code>S1 &amp; S2</code></td>
<td>测试(64位)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>设置条件码</th>
</tr>
</thead>
<tbody><tr>
<td><code>set? D</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>跳转和条件跳转</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>jmp L</code></td>
<td>跳转到标签<code>L</code></td>
<td>直接跳转</td>
</tr>
<tr>
<td><code>jmp *O</code></td>
<td>跳转到<code>*O</code>指向的标签</td>
<td>间接跳转</td>
</tr>
<tr>
<td><code>je L</code> <code>jz L</code></td>
<td><code>ZF</code>为0时跳转</td>
<td>相等跳转</td>
</tr>
<tr>
<td><code>jne L</code> <code>jnz L</code></td>
<td><code>ZF</code>为1时跳转</td>
<td>不相等跳转</td>
</tr>
<tr>
<td><code>js L</code></td>
<td><code>SF</code>为0时跳转</td>
<td>负数跳转</td>
</tr>
<tr>
<td><code>jns L</code></td>
<td><code>SF</code>为1时跳转</td>
<td>非负数跳转</td>
</tr>
<tr>
<td><code>jg L</code> <code>jnle L</code></td>
<td><code>~(SF ^ OF) &amp; ~ZF</code></td>
<td>大于跳转（有符号）</td>
</tr>
<tr>
<td><code>jge L</code> <code>jnl L</code></td>
<td><code>~(SF ^ OF)</code></td>
<td>大于等于跳转（有符号）</td>
</tr>
<tr>
<td><code>jl L</code> <code>jnge L</code></td>
<td><code>SF ^ OF</code></td>
<td>小于跳转（有符号）</td>
</tr>
<tr>
<td><code>jle L</code> <code>jng L</code></td>
<td><code>(SF ^ OF) 1 ZF</code></td>
<td>小于等于跳转（有符号）</td>
</tr>
<tr>
<td><code>ja L</code> <code>jnbe L</code></td>
<td><code>~CF &amp; ~ZF</code></td>
<td>大于跳转（无符号）</td>
</tr>
<tr>
<td><code>jae L</code> <code>jnb L</code></td>
<td><code>~CF</code></td>
<td>大于等于跳转（无符号）</td>
</tr>
<tr>
<td><code>jb L</code> <code>jnae L</code></td>
<td><code>CF ^ OF</code></td>
<td>小于跳转（无符号）</td>
</tr>
<tr>
<td><code>jbe L</code> <code>jna L</code></td>
<td><code>CF 1 ZF</code></td>
<td>小于等于跳转（无符号）</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>条件传送指令</th>
</tr>
</thead>
<tbody><tr>
<td><code>cmov? S,R</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>转移控制</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>call L</code></td>
<td></td>
<td>过程调用</td>
</tr>
<tr>
<td><code>call *O</code></td>
<td></td>
<td>过程调用</td>
</tr>
<tr>
<td><code>leave</code></td>
<td></td>
<td>为返回准备栈</td>
</tr>
<tr>
<td><code>ret</code></td>
<td></td>
<td>返回</td>
</tr>
</tbody></table>
<p>掌握条件语句和循环语句与汇编之间的转换。条件传送指令可以用来优化。switch 语句是用跳转表实现的。注意递归的实现。对数组的访问相当于用指针来访问。结构和联合，以及其他数据都要求对齐以提升性能和适应硬件。</p>
<p>学会使用 GDB 调试器。</p>
<p>理解缓冲区溢出，知道栈随机化、栈破坏检测和限制可执行代码区域的办法。</p>
<p>了解 IA32 汇编和 x86-64 汇编的区别。</p>
<h2 id="第4章-处理器体系结构"><a href="#第4章-处理器体系结构" class="headerlink" title="第4章 处理器体系结构"></a>第4章 处理器体系结构</h2><p>本章定义了一个 Y86 指令集体系结构（ISA），并以此构造出来一个处理器。</p>
<p>简单了解硬件控制语言HCL。</p>
<p>考虑两类存储器设备：存储器（随机访问存储器）和寄存器（时钟寄存器）。寄存器文件有两个读端口（A和B）和一个写端口（W）。</p>
<p>Y86 的顺序实现：取指(Fetch)、译码(Decode)、执行(Execute)、访存(Memory)、写回(Write back)、更新(Program counter update)。要知道每个汇编指令是如何按照这样的顺序在处理器中运行的。以此，实现了顺序实现的 SEQ 硬件。要知道每个过程是怎样以逻辑电路的形式表示的。</p>
<p>为了充分利用硬件单元，引入流水线。计算流水线用吞吐量（单位 GIPS）。流水线的局限性：不一致的划分、流水线过深导致的收益下降。书中实现了重新安排计算阶段设计的带反馈的流水线系统 SEQ+，并在其中插入流水线寄存器得到了 PIPE- 处理器。</p>
<p>流水线冒险是现代处理器的基本处理方式，用暂停、转发可以避免数据冒险。判断预测错误、跳转、返回会导致冒险。</p>
<p>最后实现了 PIPE 处理器，要理解每个阶段的实现。理解流水线控制逻辑和特殊情况的处理。</p>
<p>现代处理器的性能指标为CPI（每指令周期数）的倒数IPC。</p>
<h2 id="第5章-优化程序性能"><a href="#第5章-优化程序性能" class="headerlink" title="第5章 优化程序性能"></a>第5章 优化程序性能</h2><p>编译器优化的能力是有局限性的，编译器必须很小心地对程序只使用安全的优化，必须假设什么情况都有可能发生，不会去试图判断一个函数有没有副作用。</p>
<p>表示程序性能用CPE（每元素周期数）。本章用一个向量加法和乘法的程序来计算不同优化。</p>
<p>有用的优化：消除循环的低效率、减少过程调用、消除不必要的存储器引用。</p>
<p>理解现代处理器，了解处理器的整体操作、功能单元的性能。可以将机器代码转化成数据流图来分析关键路径。</p>
<p>循环展开是一种有效减少循环迭代次数的方法。</p>
<p>提高并行性可以有效提升性能，包括使用多个累积变量、重新结合变换。</p>
<p>一些限制因素：寄存器溢出、分支预测和预测错误处罚。所以不要过分关心可预测的分支，书写适合用条件传送实现的代码。</p>
<p>理解存储器性能。</p>
<p>使用剖析程序 <code>gprof</code> 来分析程序，并利用剖析器来指导优化：</p>
<pre><code>gcc -O1 -pg &lt;source&gt;.c    # 选项 -pg
./a.out                   # 运行后生成 gmon.out 文件
gprof a.out               # 生成分析报告
</code></pre>
<p>Amdahl定律：假设系统某个部分需要占用$\alpha$的时间，而我们将它的性能提高到了$k$倍，则加速比为$$S=\frac{1}{1-\alpha+\frac{\alpha}{k}}$$</p>
<h2 id="第6章-存储器层次结构"><a href="#第6章-存储器层次结构" class="headerlink" title="第6章 存储器层次结构"></a>第6章 存储器层次结构</h2><ol>
<li>随机访问存储器<ol>
<li>SRAM：状态稳定，每个单元用一个六晶体管电路实现</li>
<li>DRAM：对干扰敏感，每个存储器但愿用一个电容和一个访问晶体管组成</li>
<li>传统DRAM：$d\times w, (d=rc)$</li>
<li>存储器模块DIMM和SIMM</li>
<li>增强的DRAM：<ul>
<li>FPM DRAM</li>
<li>EDO DRAM</li>
<li>SDRAM</li>
<li>DDR SDRAM：双倍数据速率同步DRAM，包括DDR、DDR2、DDR3</li>
<li>VRAM</li>
</ul>
</li>
<li>非易失性存储器：<ul>
<li>PROM：可编程ROM，用高电流熔断熔丝来编程</li>
<li>EPROM：可擦写可编程ROM，用紫外线擦写石英窗口</li>
<li>EEPROM：电子可擦写PROM，直接在印制电路卡上编程</li>
<li>闪存/固态硬盘：基于EEPROM</li>
</ul>
</li>
<li>存储器总线：访问主存</li>
</ol>
</li>
<li>磁盘存储<ol>
<li>磁盘构造：盘片、表面、主轴、旋转速率RPM（转每分种）；磁道、扇区、间隙</li>
<li>磁盘容量：记录密度、磁道密度、面密度；多区记录技术 $$磁盘容量=\frac{字节数}{扇区}\times\frac{平均扇区数}{磁道}\times\frac{磁道数}{表面}\times\frac{表面数}{盘片}\times\frac{盘片数}{磁盘}$$</li>
<li>磁盘操作：读写头、传动臂、寻道；寻道时间、旋转时间、传送时间</li>
<li>逻辑磁盘块</li>
<li>链接到I/O设备：通用串行总线（USB）、图形适配器、主机总线适配器</li>
<li>访问磁盘：存储器映射I/O</li>
<li>商用磁盘剖析</li>
</ol>
</li>
<li>固态硬盘：闪存翻译层</li>
<li>存储技术趋势</li>
</ol>
<p>局部性：对程序数据引用的局部性、取指令的局部性。</p>
<p>存储器层级结构：寄存器、一级高速缓存、二级高速缓存、三级高速缓存、主存、固态硬盘、本地磁盘、远程存储。</p>
<p>高速缓存：缓存命中、缓存不命中。高速缓存存储器的结构用元组$(S,E,B,m)$即（组，行，块，位）描述，高速缓存的大小$C=S\times E\times B$。直接映射高速缓存，分为三步：组选择、行匹配、字抽取。书中用一个例子描述了运行中的直接映射高速缓存。组相联高速缓存在书中也给出了详细的描述。</p>
<p>高速缓存的写主要是以写回的方式实现的，即当存储器被更新时才写回下一级缓存。</p>
<p>编写高速缓存友好的代码：让最常见的情况运行得快、让每个循环内部缓存不命中数量最小。</p>
<p>存储器山。</p>
<p>重写排列循环可以提高空间局部性，比如矩阵乘法的最快版本是kij和ikj版本，内循环步增可以最好地提升空间局部性。</p>
<h1 id="第二部分-在系统上运行程序"><a href="#第二部分-在系统上运行程序" class="headerlink" title="第二部分 在系统上运行程序"></a>第二部分 在系统上运行程序</h1><h2 id="第7章-链接"><a href="#第7章-链接" class="headerlink" title="第7章 链接"></a>第7章 链接</h2><p>编译程序的基本步骤：</p>
<ol>
<li><code>cpp</code> 预处理器，输出<code>*.i</code></li>
<li><code>cc1</code> 编译器，输出<code>*.s</code></li>
<li><code>as</code> 汇编器，输出<code>*.o</code></li>
<li><code>ld</code> 链接器，输出<code>a.out</code></li>
<li><code>./a.out</code> 可执行二进制文件</li>
</ol>
<p><code>ld</code>是静态链接器，进行符号解析和重定位。</p>
<p>目标文件有三种形式：可重定位目标文件、可执行目标文件、共享目标文件。</p>
<p>Unix可执行和可链接格式（ELF）：</p>
<ul>
<li>ELF头</li>
<li>.text 已编译程序的机器代码</li>
<li>.rodata 只读数据</li>
<li>.data 已初始化的全局变量</li>
<li>.bss 未初始化的全局变量</li>
<li>.symtab 符号表</li>
<li>.rel.text 位置引用表</li>
<li>.rel.data 重定位引用信息</li>
<li>.debug 调试信息</li>
<li>.line 行号信息</li>
<li>.strtab 字符串表</li>
</ul>
<p>符号和符号表、符号解析。解析多重定义符号，与静态库链接，链接器解析静态库引用。</p>
<p>重定位：重定位条目、重定位符号引用。</p>
<p>可执行目标文件，加载可执行目标文件，动态链接共享库。与位置无关的代码（PIC）。</p>
<h2 id="第8章-异常控制流"><a href="#第8章-异常控制流" class="headerlink" title="第8章 异常控制流"></a>第8章 异常控制流</h2><p>异常就是控制流中的突变，用来相应处理器状态中的某些变化。</p>
<p>异常包括：中断（interrupt）、陷阱（trap）、故障（fault）、终止（abort）。系统调用是一种陷阱。</p>
<p>进程。逻辑控制流、并发流、私有地址空间、用户模式和内核模式、上下文切换。</p>
<p>进程控制：获取进程编号、创建和终止进程、回收子进程。加载并运行程序。</p>
<p>信号：发送信号、接收信号、信号处理问题、信号阻塞和取消阻塞。</p>
<p>长跳转。</p>
<h2 id="第9章-虚拟存储器"><a href="#第9章-虚拟存储器" class="headerlink" title="第9章 虚拟存储器"></a>第9章 虚拟存储器</h2><h1 id="第三部分-程序间的交互和通信"><a href="#第三部分-程序间的交互和通信" class="headerlink" title="第三部分 程序间的交互和通信"></a>第三部分 程序间的交互和通信</h1><h2 id="第10章-系统级-I-O"><a href="#第10章-系统级-I-O" class="headerlink" title="第10章 系统级 I/O"></a>第10章 系统级 I/O</h2><h2 id="第11章-网络编程"><a href="#第11章-网络编程" class="headerlink" title="第11章 网络编程"></a>第11章 网络编程</h2><h2 id="第12章-并发编程"><a href="#第12章-并发编程" class="headerlink" title="第12章 并发编程"></a>第12章 并发编程</h2><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1></div><hr></div><div class="recent-post-item"><a class="article-title" href="/core-java/">《Java 核心技术》</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2015-03-08</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%AE%80%E6%9B%B8%E7%AD%86%E8%A8%98/">讀書筆記</a></span><div class="content"><p><a target="_blank" rel="noopener" href="http://horstmann.com/corejava">Horstmann的官方网站</a></p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>这本书是一本比较全面的入门书，基于Java 7，伴随着大量示例和对C/C++的比较。当然这种书有点啰嗦，所以看完核心的部分后，所谓高级内容基本都是简单带过，只了解了一下有哪些库、哪些功能。这种书看一遍就够了，关于JDK提供的功能只要查阅文档即可。</p>
<h2 id="卷Ⅰ-基础知识"><a href="#卷Ⅰ-基础知识" class="headerlink" title="卷Ⅰ 基础知识"></a>卷Ⅰ 基础知识</h2><h3 id="1-Java程序设计概述"><a href="#1-Java程序设计概述" class="headerlink" title="1. Java程序设计概述"></a>1. Java程序设计概述</h3><p>简介Java。</p>
<h3 id="2-Java程序设计环境"><a href="#2-Java程序设计环境" class="headerlink" title="2. Java程序设计环境"></a>2. Java程序设计环境</h3><p>安装设置JDK。</p>
<h3 id="3-Java的基本程序设计结构"><a href="#3-Java的基本程序设计结构" class="headerlink" title="3. Java的基本程序设计结构"></a>3. Java的基本程序设计结构</h3><p>Java基本语法。类似C++。</p>
<h3 id="4-对象与类"><a href="#4-对象与类" class="headerlink" title="4. 对象与类"></a>4. 对象与类</h3><p>类：构造器、访问权限、final。包。类路径。文档注释。</p>
<h3 id="5-继承"><a href="#5-继承" class="headerlink" title="5. 继承"></a>5. 继承</h3><p>多态、动态绑定、强制类型转换、抽象类。</p>
<p>超类Object：equals/hashCode/toString方法。</p>
<p>泛型数组列表。对象包装器和自动装箱。可变参数。</p>
<p>反射。</p>
<h3 id="6-接口与内部类"><a href="#6-接口与内部类" class="headerlink" title="6. 接口与内部类"></a>6. 接口与内部类</h3><p>接口与回调。对象克隆。内部类的特殊语法。</p>
<h3 id="7-图形程序设计"><a href="#7-图形程序设计" class="headerlink" title="7. 图形程序设计"></a>7. 图形程序设计</h3><p>简单的Swing介绍。</p>
<h3 id="8-事件处理"><a href="#8-事件处理" class="headerlink" title="8. 事件处理"></a>8. 事件处理</h3><p>动作和鼠标事件。</p>
<h3 id="9-Swing用户界面组件"><a href="#9-Swing用户界面组件" class="headerlink" title="9. Swing用户界面组件"></a>9. Swing用户界面组件</h3><p>MVC设计模式。</p>
<p>布局管理：边框布局、网格布局、组布局或自定义。</p>
<p>文本域、标签、密码域、文本区、滚动窗格，复选框、单选按钮、边框、组合框、滑动条。菜单、快捷键、工具栏。对话框。</p>
<h3 id="10-部署应用程序和applet"><a href="#10-部署应用程序和applet" class="headerlink" title="10. 部署应用程序和applet"></a>10. 部署应用程序和applet</h3><p>JAR文件。</p>
<p>Java Web Start和applet。</p>
<p>应用程序首选项存储。</p>
<h3 id="11-异常、断言、日志和调试"><a href="#11-异常、断言、日志和调试" class="headerlink" title="11. 异常、断言、日志和调试"></a>11. 异常、断言、日志和调试</h3><p>如题。</p>
<h3 id="12-泛型程序设计"><a href="#12-泛型程序设计" class="headerlink" title="12. 泛型程序设计"></a>12. 泛型程序设计</h3><p>泛型、约束与局限性、反射。</p>
<h3 id="13-集合"><a href="#13-集合" class="headerlink" title="13. 集合"></a>13. 集合</h3><p>集合接口、集合框架。具体的集合和算法。</p>
<h3 id="14-多线程"><a href="#14-多线程" class="headerlink" title="14. 多线程"></a>14. 多线程</h3><p>如题。</p>
<h2 id="卷Ⅱ-高级特性"><a href="#卷Ⅱ-高级特性" class="headerlink" title="卷Ⅱ 高级特性"></a>卷Ⅱ 高级特性</h2><h3 id="1-流与文件"><a href="#1-流与文件" class="headerlink" title="1. 流与文件"></a>1. 流与文件</h3><p>Reader/Writer/Stream这些类的使用，文本的输入输出，读写二进制数据和ZIP文档。对象流与序列化。操作文件的Path。内存映射文件。正则表达式。</p>
<h3 id="2-XML"><a href="#2-XML" class="headerlink" title="2. XML"></a>2. XML</h3><p>XML的解析、生成，使用XSL转换。用XML指定Swing布局。便利的XPath。</p>
<h3 id="3-网络"><a href="#3-网络" class="headerlink" title="3. 网络"></a>3. 网络</h3><p>使用套接字，实现服务器和客户端。URL和URI。提交表单。发送E-mail。</p>
<h3 id="4-数据库编程"><a href="#4-数据库编程" class="headerlink" title="4. 数据库编程"></a>4. 数据库编程</h3><p>JDBC的配置、SQL。可滚动结果集、行集。元数据和事务。</p>
<h3 id="5-国际化"><a href="#5-国际化" class="headerlink" title="5. 国际化"></a>5. 国际化</h3><p>Locales。数字、日期时间、排序、字符集。资源包。</p>
<h3 id="6-高级-Swing"><a href="#6-高级-Swing" class="headerlink" title="6. 高级 Swing"></a>6. 高级 Swing</h3><p>列表框、表格、树形框、功能化的文本框、进度条、分割面板、选项卡面板等。</p>
<h3 id="7-高级-AWT"><a href="#7-高级-AWT" class="headerlink" title="7. 高级 AWT"></a>7. 高级 AWT</h3><p>绘图和图像处理、图像的读入和写出。打印。剪贴板。拖放。闪屏。系统托盘。</p>
<h3 id="8-JavaBean-构件"><a href="#8-JavaBean-构件" class="headerlink" title="8. JavaBean 构件"></a>8. JavaBean 构件</h3><p>Bean的编写、构造应用程序和打包、属性和属性编辑器、定制器。BeanInfo 类。JavaBean持久化。</p>
<h3 id="9-安全"><a href="#9-安全" class="headerlink" title="9. 安全"></a>9. 安全</h3><p>类加载器、字节码校验、数字签名、代码签名。</p>
<h3 id="10-脚本、编译与注解处理"><a href="#10-脚本、编译与注解处理" class="headerlink" title="10. 脚本、编译与注解处理"></a>10. 脚本、编译与注解处理</h3><p>JavaScript、Groovy、Scheme引擎。编译器API。注解和标准注解。</p>
<h3 id="11-分布式对象"><a href="#11-分布式对象" class="headerlink" title="11. 分布式对象"></a>11. 分布式对象</h3><p>通过实现一个RMI来介绍。</p>
<h3 id="12-本地方法"><a href="#12-本地方法" class="headerlink" title="12. 本地方法"></a>12. 本地方法</h3><p>JNI调用本地的C函数和API。访问Windows注册表。</p>
</div><hr></div><div class="recent-post-item"><a class="article-title" href="/java-encoding-set/">Java 编译时的编码设置</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2015-03-08</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E7%BC%96%E7%A0%81/">编码</a></span><div class="content"><p>在 UTF-8 成为事实文本编码标准的现在，我的所有程序都是 UTF-8 编码的。</p>
<p>编写 Java 程序，默认使用 <code>javac</code> 直接在 Windows 命令提示符下编译含有汉字的源代码，会报错：</p>
<div class="alert alert-danger" role="alert">
    错误: 编码GBK的不可映射字符
</div>

<p>解决办法也很简单，指定编码即可：</p>
<pre><code>javac -encoding UTF-8 &lt;文件名&gt;
</code></pre>
<p>在 Eclipse 中则可以在属性中配置。</p>
<p>javadoc 也会产生相同的问题，在命令行参数中或在 Eclipse 中的 Generate Javadoc 的 VM options 中加入：</p>
<pre><code>-encoding utf-8 -charset utf-8
</code></pre>
<p>Linux 默认编码就是 UTF-8，没有这个问题。</p>
</div><hr></div><div class="recent-post-item"><a class="article-title" href="/the-pragmatic-programmer/">《程序员修炼之道》</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2015-03-08</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%AE%80%E6%9B%B8%E7%AD%86%E8%A8%98/">讀書筆記</a></span><div class="content"><p>书是 2000年的东西了，但其中的思想并不过时。这本书我看的是电子工业出版社的评注版和翻译版。这里主要摘录蔡学镛和周爱民的评注版，他从批判的视角重新审视了书中一些并不合适的观点。我认为，对于这些观点的冲突，应该从中看到其共性，思考后谨慎行事。</p>
<h3 id="第一章-务实的哲学"><a href="#第一章-务实的哲学" class="headerlink" title="第一章 务实的哲学"></a>第一章 务实的哲学</h3><p>务实的程序员需要具备特定的态度、风格、哲学：</p>
<ol>
<li>有格局的眼光</li>
<li>富有责任感</li>
<li>愿意改变</li>
<li>可以平衡取舍</li>
<li>丰富的知识和技能</li>
<li>良好的沟通能力</li>
</ol>
<p>程序员是人，人都会犯错。要承认问题并找出补救办法。不能怪别人。</p>
<p>软件是复杂的。</p>
<p>“破窗理论”。务实的程序员要防微杜渐，时刻防止潜在问题的发生，让项目保持在正确的轨道上前进而不会逐渐失控。</p>
<p>要有改变的能力和改变别人的能力。</p>
<p>利用现有的资源做出合理的第一版系统是很关键的一步。</p>
<p>不要只专心处理自己的事情，要随时观察整个大环境的变化。</p>
<p>完美的代码是不存在的，尽快推出足够好但不完美的产品比较重要。</p>
<p>系统需求文档中应该明确地给出系统范畴与质量要求。</p>
<p>程序员必须持续学习与实践，积累丰富的知识与经验。</p>
<p>选择不同的编程范式进行学习。多读技术书和非技术书。学习的过程激活了我们的大脑，改变了我们的行为。</p>
<p>程序员除了写代码，也要懂得如何与新项目的其他参与者沟通，甚至与客户沟通。</p>
<h3 id="第二章-务实的方法"><a href="#第二章-务实的方法" class="headerlink" title="第二章 务实的方法"></a>第二章 务实的方法</h3><p>一开始就要严格避免程序中存在重复的代码，并持续保持这样的严谨态度。一旦我们破除“不得不”的心理限制，许多原本“不得不重复”的状况也就有解了。</p>
<p>我们要让自己写出来的代码易于复用。</p>
<p>良好的系统设计应该让系统的组成分子之间互相独立。开发人员的责任要划分清楚，避免存在交叉的灰色地带。</p>
<p>保留足够可逆转的弹性，让现在做的决定以后可以被轻易地改变。</p>
<p>最好地方是应该是先动手，然后观察各种反馈，立即改进——“曳光弹”。一定要考虑清楚何时用曳光弹，何时用原型系统，何时用纸笔。</p>
<h3 id="第三章-基本工具"><a href="#第三章-基本工具" class="headerlink" title="第三章 基本工具"></a>第三章 基本工具</h3><p>纯文本是最好的格式。把可读的纯文本当作数据格式，这样的数据会比创建此数据的应用活得更久。</p>
<p>使用IDE、使用Shell、使用编辑器。使用版本控制。</p>
<p>调试之前，调整好心理状态。丢弃防卫心、忘掉项目的压力，不要惊慌。找到Bug的根源，彻底解决它，而不是绕过它。</p>
<p>精通一种文本处理的语言。</p>
<h3 id="第四章-务实的执着"><a href="#第四章-务实的执着" class="headerlink" title="第四章 务实的执着"></a>第四章 务实的执着</h3><p>通过契约式设计，代码中的问题可以尽早曝光，调试比较容易。</p>
<p>任何假设都不应该存在。使用断言，保留一张安全防护网。</p>
<p>程序资源的取用要一一照应。</p>
<h3 id="第五章-解耦的重要性"><a href="#第五章-解耦的重要性" class="headerlink" title="第五章 解耦的重要性"></a>第五章 解耦的重要性</h3><p>软件设计应当使每个模块之间互相独立，避免牵一发而动全身。</p>
<p>解耦会导致代码量的增加和程序性能的下降，要做好取舍。</p>
<p>应该把细节（数据）独立出来，不要将其混在代码中。将抽象写在代码中，将细节写在元数据中。</p>
<p>分析工作流程，以达到时间解耦的目的，从而让许多任务之间不再存在时序，可以并发执行。</p>
<p>MVC 是有效的解耦方案。</p>
<h3 id="第六章-编码之时"><a href="#第六章-编码之时" class="headerlink" title="第六章 编码之时"></a>第六章 编码之时</h3><p>不能够碰运气写代码，让程序运行起来并不够，还必须知道代码是如何运行的。</p>
<p>少使用设置向导自动生成代码。</p>
<p>算法也需要重视。</p>
<p>时时重构。一旦发现代码中要不好的地方，就立即重构！</p>
<p>代码需要测试。契约式设计是不错的方式。自动化测试也是有用的。</p>
<h3 id="第七章-项目需求"><a href="#第七章-项目需求" class="headerlink" title="第七章 项目需求"></a>第七章 项目需求</h3><p>你可能面临的多数需求，既不完整也毫无意义。而一个专业的程序员的职责在于完成程序，而非讨论它的价值。</p>
<p>做技术要专心自己的职责，只有长期修炼之后，才能看到需求和它背后的问题与决策，这时你才有发言权。</p>
<hr>
<p>当然我们还是要关注需求的。</p>
<h3 id="第八章-项目实践"><a href="#第八章-项目实践" class="headerlink" title="第八章 项目实践"></a>第八章 项目实践</h3><p>关于软件工程的一堆……</p>
<p>自动文档，使用标记语言。自动生成代码。自动生成测试。</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/4/">&lt;i class&#x3D;&quot;fa fa-chevron-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/6/">&lt;i class&#x3D;&quot;fa fa-chevron-right&quot;&gt;&lt;&#x2F;i&gt;</a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2008 - 2021 原田莓莓</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.2"></script><script src="/js/fancybox.js?version=1.5.2"></script><script src="/js/sidebar.js?version=1.5.2"></script><script src="/js/copy.js?version=1.5.2"></script><script src="/js/fireworks.js?version=1.5.2"></script><script src="/js/transition.js?version=1.5.2"></script><script src="/js/scroll.js?version=1.5.2"></script><script src="/js/head.js?version=1.5.2"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>