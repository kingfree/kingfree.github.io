---
title: 《深入理解计算机系统》
tagline: 原书第2版
etitle: "Computer Systems: A Programmer's Perspective"
categories: 讀書筆記
date: 2015-3-12
update: 2015-6-22
---

## 第1章 计算机系统漫游

信息就是 位+上下文。

程序编译的四个阶段：预处理阶段 `cpp`、编译阶段 `cc1`、汇编阶段 `as`、链接阶段 `ld`。

为何要了解编译系统的工作方式：优化程序性能、理解链接时出现的错误、避免安全漏洞。

系统的硬件组成：总线、I/O 设备、主存、处理器。演示了`hello`程序的运行过程。

三级高速缓存。存储器层次结构的金字塔。

操作系统管理硬件：进程和线程、虚拟存储器、文件。

并发和并行。

# 第一部分 程序结构和执行

## 第2章 信息的表示和处理

十六进制表示法，十六进制、二进制、十进制之间的转换。

字和字长、大端法和小端法。

布尔代数，位级运算、逻辑运算、移位运算。

整数的表示法：

* 无符号整数 $$B2U_w(\vec{x})\doteq\sum_{i=0}^{w-1}{x_i2^i}$$
* 补码 $$B2T_w(\vec{x})\doteq -x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}{x_i2^i}$$
* 反码、原码

* 补码转无符号数：$$T2U_w(x)=\left\{\begin{array}{ll}x+2^w,& x<0\\x,& x\ge 0\end{array}\right.$$,
* 无符号数转补码：$$U2T_w(u)=\left\{\begin{array}{ll}u,& u<2^{w-1}\\x-2^w,& u\ge 2^{w-1}\end{array}\right.$$

C 隐式地将有符号参数强制转换为无符号数并假设其非负来进行计算。

数字的扩展：

* 零扩展
* 符号扩展：$$B2T_{w+k}([x_{w-1},\cdots,x_{w-1},x_{w-1},x_{w-2},\cdots,x_0])=B2T_{w}([x_{w-1},x_{w-2},\cdots,x_0])$$

数的截断：

* 无符号数的截断：$$B2U_k([x_{k-1},x_{k-2},\cdots,x_0])=B2U_{w}([x_{w-1},x_{w-2},\cdots,x_0])\mod {2^k}$$
* 有符号数的截断：$$B2T_k([x_{k-1},x_{k-2},\cdots,x_0])=U2T_k(B2U_{w}([x_{w-1},x_{w-2},\cdots,x_0])\mod {2^k})$$

整数的运算：

* 无符号加法：$$x+^u_w y=\left\{\begin{array}{ll}x+y,& x+y<2^w\\x+y-2^w,& 2^w\le x+y<2^{w+1}\end{array}\right.$$
* 补码加法：$$x+^t_w y=U2T_w[(x+y)\mod {2^w}]=\left\{\begin{array}{lll}
x+y-2^w,& 2^{w-1}\le x+y, & \text{正溢出}\\
x+y,& -2^{w-1}\le x+y<2^{w-1},& \text{正常}\\
x+y+2^w,& x+y<-2^{w-1}, & \text{负溢出}
\end{array}\right.$$
* 补码的非：$$-^t_w x=\left\{\begin{array}{ll}-2^{w-1},& x=-2^{w-1}\\-x,& x>-2^{w-1}\end{array}\right.$$
* 无符号乘法：$$x*^u_w y=(x\cdot y)\mod {2^w}$$
* 补码乘法：$$x*^t_w y=U2T_w((x\cdot y)\mod {2^w})$$
* 乘以常数：$$B2U_{w+k}([x_{w-1},x_{w-2},\cdots,x_0,0,\cdots,0])=x2^k$$
* 除以2的幂：$$x/2^k=$$`(x < 0 ? (x + (1 << k) - 1) : x) >> k`

浮点数：

* 二进制小数（定点小数）
* IEEE 浮点小数：规格化的值、非规格化的值、无穷大、NaN。
* 舍入
* 浮点运算

## 第3章 程序的机器级表示

本章主要讲的是 IA32 汇编。在命令行上使用 `-S` 产生 AT&T 格式的汇编代码：

	gcc -O1 -S -m32 <源文件>

实际的编译代码和书上讲的略有区别，并且不同的优化选项也会产生不同的汇编代码。

#### 整数寄存器

| 四字寄存器(64位) | 双字寄存器(32位) | 字寄存器(16位) | 高字节寄存器| 低字节寄存器 | |
| 63-31| 31-15| 15-0| 15-8| 7-0 | 64位下的作用 |
| %rax | **%eax** | **%ax** | **%ah** | **%al** | 返回值 |
| %rbx | **%ebx** | **%bx** | **%bh** | **%bl** | 被调用者保存 |
| %rcx | **%ecx** | **%cx** | **%ch** | **%cl** | 第4个参数 |
| %rdx | **%edx** | **%dx** | **%dh** | **%dl** | 第3个参数 |
| %rsi | **%esi** | **%si** |    | %sil | 第2个参数 |
| %rdi | **%edi** | **%di** |    | %dil | 第1个参数 |
| %rbp | **%ebp** | **%bp** |    | %bpl | 被调用者保存 |
| %rsp | **%esp** | **%sp** |    | %spl | 栈指针 |
| %r8  | %r8d | %r8w |   | %r8b | 第5个参数 |
| %r9  | %r9d | %r9w |   | %r9b | 第6个参数 |
| %r10 | %r10d| %r10w|  | %r10b | 调用者保存 |
| %r11 | %r11d| %r11w|  | %r11b | 调用者保存 |
| %r12 | %r12d| %r12w|  | %r12b | 被调用者保存 |
| %r13 | %r13d| %r13w|  | %r13b | 被调用者保存 |
| %r14 | %r14d| %r14w|  | %r14b | 被调用者保存 |
| %r15 | %r15d| %r15w|  | %r15b | 被调用者保存 |

#### 操作数指示符

| 立即数 | `$Imm` | `Imm`   | 立即数寻址 |
| 寄存器 | `Ea`   | `R[Ea]` | 寄存器寻址 |
| 存储器 | `Imm`  | `M[Imm]` | 绝对寻址 |
| 存储器 | `Imm(Eb,Ei,s)` | `M[Imm+R[Eb]+R[Ej]*s]` | 比例变址寻址 |

#### 条件码

| `CF` | 进位标志 | |
| `ZF` | 零标志 | |
| `SF` | 符号标志 | |
| `OF` | 移除标志 | |

#### 汇编指令

| 数据传送指令 |
| `movb S,D` | 传送字节S到D | 传送 |
| `movw S,D` | 传送字S到D | 传送 |
| `movl S,D` | 传送双字S到D | 传送 |
| `movabsq R,I` | 传送立即数I到寄存器R | 传送(64位) |
| `movq S,D` | 传送四字S到D | 传送(64位) |
| `movsbw S,D` | 传送符号扩展字节S到字D | 符号传送 |
| `movsbl S,D` | 传送符号扩展字节S到双字D | 符号传送 |
| `movswl S,D` | 传送符号扩展字S到双字D | 符号传送 |
| `movsbq S,D` | 传送符号扩展字节S到四字D | 符号传送 |
| `movswq S,D` | 传送符号扩展字S到四字D | 符号传送 |
| `movslq S,D` | 传送符号扩展双字S到四字D | 符号传送 |
| `movzbw S,D` | 传送零扩展字节S到字D | 零传送 |
| `movzbl S,D` | 传送零扩展字节S到双字D | 零传送 |
| `movzwl S,D` | 传送零扩展字S到双字D | 零传送 |
| `movzbq S,D` | 传送零扩展字节S到四字D | 零传送(64位) |
| `movzwq S,D` | 传送零扩展字S到四字D | 零传送(64位) |
| `movzlq S,D` | 传送零扩展双字S到四字D | 零传送(64位) |
| `pushl S` | `R[%esp] -= 4;   M[R[%esp]] = S` | 压栈 |
| `popl D`  | `D = M[R[%esp]]; R[%esp] += 4` | 弹栈 |
| `pushq S` | `R[%rsp] -= 8;   M[R[%rsp]] = S` | 压栈(64位) |
| `popq D`  | `D = M[R[%rsp]]; R[%rsp] += 8` | 弹栈(64位) |
| 基本算术操作 |
| `leal S,D` | `D = &S` | 加载有效地址 |
| `inc D` | `D++` | 递增 |
| `dec D` | `D--` | 递减 |
| `neg D` | `D = -D` | 取反 |
| `not D` | `D = ~D` | 取非 |
| `add S,D` | `D += S` | 加 |
| `sub S,D` | `D -= S` | 减 |
| `imul S,D` | `D *= S` | 乘 |
| `xor S,D` | `D ^= S` | 异或 |
| `or S,D` | `D \|= S` | 或 |
| `and S,D` | `D &= S` | 与 |
| `sal k,D` | `D <<= k` | 左移 |
| `shl k,D` | `D <<= k` | 左移 |
| `sar k,D` | `D >>= k` | 算术右移 |
| `shr k,D` | `D >>>= k` | 逻辑右移 |
| 特殊算术操作 |
| `imull S` | `R[%edx]:R[%eax] = S * R[%eax]` | 有符号乘法 |
| `mull S`  | `R[%edx]:R[%eax] = S * R[%eax]` | 无符号乘法 |
| `cltd`    | `R[%edx]:R[%eax] = R[%eax]` | 有符号扩展 |
| `idivl S` | `R[%edx] = R[%edx]:R[%eax] % S` | 有符号除法 |
|           | `R[%eax] = R[%edx]:R[%eax] / S` |  |
| `divl S`  | `R[%edx] = R[%edx]:R[%eax] % S` | 无符号除法 |
|           | `R[%eax] = R[%edx]:R[%eax] / S` |  |
| `imulq S` | `R[%rdx]:R[%rax] = S * R[%rax]` | 有符号乘法(64位) |
| `mulq S`  | `R[%rdx]:R[%rax] = S * R[%rax]` | 无符号乘法(64位) |
| `cltdq`   | `R[%rdx]:R[%rax] = R[%rax]` | 有符号扩展(64位) |
| `idivq S` | `R[%rdx] = R[%rdx]:R[%rax] % S` | 有符号除法(64位) |
|           | `R[%rax] = R[%rdx]:R[%rax] / S` |  |
| `divq S`  | `R[%rdx] = R[%rdx]:R[%rax] % S` | 无符号除法(64位) |
|           | `R[%rax] = R[%rdx]:R[%rax] / S` |  |
| 比较和测试指令 |
| `cmpb S2,S1` | 比较字节 `S1 - S2` | 比较 |
| `cmpw S2,S1` | 比较单字 `S1 - S2` | 比较 |
| `cmpl S2,S1` | 比较双字 `S1 - S2` | 比较 |
| `cmpq S2,S1` | 比较四字 `S1 - S2` | 比较(64位) |
| `testb S2,S1` | 测试字节 `S1 & S2` | 测试 |
| `testw S2,S1` | 测试单字 `S1 & S2` | 测试 |
| `testl S2,S1` | 测试双字 `S1 & S2` | 测试 |
| `testq S2,S1` | 测试四字 `S1 & S2` | 测试(64位) |
| 设置条件码 |
| `set? D` |
| 跳转和条件跳转 |
| `jmp L` | 跳转到标签`L` | 直接跳转 |
| `jmp *O` | 跳转到`*O`指向的标签 | 间接跳转 |
| `je L` `jz L` | `ZF`为0时跳转 | 相等跳转 |
| `jne L` `jnz L` | `ZF`为1时跳转 | 不相等跳转 |
| `js L` | `SF`为0时跳转 | 负数跳转 |
| `jns L` | `SF`为1时跳转 | 非负数跳转 |
| `jg L` `jnle L` | `~(SF ^ OF) & ~ZF` | 大于跳转（有符号） |
| `jge L` `jnl L` | `~(SF ^ OF)` | 大于等于跳转（有符号） |
| `jl L` `jnge L` | `SF ^ OF` | 小于跳转（有符号） |
| `jle L` `jng L` | `(SF ^ OF) | ZF` | 小于等于跳转（有符号） |
| `ja L` `jnbe L` | `~CF & ~ZF` | 大于跳转（无符号） |
| `jae L` `jnb L` | `~CF` | 大于等于跳转（无符号） |
| `jb L` `jnae L` | `CF ^ OF` | 小于跳转（无符号） |
| `jbe L` `jna L` | `CF | ZF` | 小于等于跳转（无符号） |
| 条件传送指令 |
| `cmov? S,R` |
| 转移控制 |
| `call L` | | 过程调用 |
| `call *O` | | 过程调用 |
| `leave` | | 为返回准备栈 |
| `ret` | | 返回 |

掌握条件语句和循环语句与汇编之间的转换。条件传送指令可以用来优化。switch 语句是用跳转表实现的。注意递归的实现。对数组的访问相当于用指针来访问。结构和联合，以及其他数据都要求对齐以提升性能和适应硬件。

学会使用 GDB 调试器。

理解缓冲区溢出，知道栈随机化、栈破坏检测和限制可执行代码区域的办法。

了解 IA32 汇编和 x86-64 汇编的区别。
	
## 第4章 处理器体系结构

本章定义了一个 Y86 指令集体系结构（ISA），并以此构造出来一个处理器。

简单了解硬件控制语言HCL。

考虑两类存储器设备：存储器（随机访问存储器）和寄存器（时钟寄存器）。寄存器文件有两个读端口（A和B）和一个写端口（W）。

Y86 的顺序实现：取指(Fetch)、译码(Decode)、执行(Execute)、访存(Memory)、写回(Write back)、更新(Program counter update)。要知道每个汇编指令是如何按照这样的顺序在处理器中运行的。以此，实现了顺序实现的 SEQ 硬件。要知道每个过程是怎样以逻辑电路的形式表示的。

为了充分利用硬件单元，引入流水线。计算流水线用吞吐量（单位 GIPS）。流水线的局限性：不一致的划分、流水线过深导致的收益下降。书中实现了重新安排计算阶段设计的带反馈的流水线系统 SEQ+，并在其中插入流水线寄存器得到了 PIPE- 处理器。

流水线冒险是现代处理器的基本处理方式，用暂停、转发可以避免数据冒险。判断预测错误、跳转、返回会导致冒险。

最后实现了 PIPE 处理器，要理解每个阶段的实现。理解流水线控制逻辑和特殊情况的处理。

现代处理器的性能指标为CPI（每指令周期数）的倒数IPC。

## 第5章 优化程序性能

编译器优化的能力是有局限性的，编译器必须很小心地对程序只使用安全的优化，必须假设什么情况都有可能发生，不会去试图判断一个函数有没有副作用。

表示程序性能用CPE（每元素周期数）。本章用一个向量加法和乘法的程序来计算不同优化。

有用的优化：消除循环的低效率、减少过程调用、消除不必要的存储器引用。

理解现代处理器，了解处理器的整体操作、功能单元的性能。可以将机器代码转化成数据流图来分析关键路径。

循环展开是一种有效减少循环迭代次数的方法。

提高并行性可以有效提升性能，包括使用多个累积变量、重新结合变换。

一些限制因素：寄存器溢出、分支预测和预测错误处罚。所以不要过分关心可预测的分支，书写适合用条件传送实现的代码。

理解存储器性能。

使用剖析程序 `gprof` 来分析程序，并利用剖析器来指导优化：

	gcc -O1 -pg <source>.c    # 选项 -pg
	./a.out                   # 运行后生成 gmon.out 文件
	gprof a.out               # 生成分析报告

Amdahl定律：假设系统某个部分需要占用$$\alpha$$的时间，而我们将它的性能提高到了$$k$$倍，则加速比为$$S=\frac{1}{1-\alpha+\frac{\alpha}{k}}$$

## 第6章 存储器层次结构

1. 随机访问存储器
	1. SRAM：状态稳定，每个单元用一个六晶体管电路实现
	2. DRAM：对干扰敏感，每个存储器但愿用一个电容和一个访问晶体管组成
	3. 传统DRAM：$$d\times w, (d=rc)$$
	4. 存储器模块DIMM和SIMM
	5. 增强的DRAM：
		* FPM DRAM
		* EDO DRAM
		* SDRAM
		* DDR SDRAM：双倍数据速率同步DRAM，包括DDR、DDR2、DDR3
		* VRAM
	6. 非易失性存储器：
		* PROM：可编程ROM，用高电流熔断熔丝来编程
		* EPROM：可擦写可编程ROM，用紫外线擦写石英窗口
		* EEPROM：电子可擦写PROM，直接在印制电路卡上编程
		* 闪存/固态硬盘：基于EEPROM
	7. 存储器总线：访问主存
2. 磁盘存储
	1. 磁盘构造：盘片、表面、主轴、旋转速率RPM（转每分种）；磁道、扇区、间隙
	2. 磁盘容量：记录密度、磁道密度、面密度；多区记录技术 $$磁盘容量=\frac{字节数}{扇区}\times\frac{平均扇区数}{磁道}\times\frac{磁道数}{表面}\times\frac{表面数}{盘片}\times\frac{盘片数}{磁盘}$$
	3. 磁盘操作：读写头、传动臂、寻道；寻道时间、旋转时间、传送时间
	4. 逻辑磁盘块
	5. 链接到I/O设备：通用串行总线（USB）、图形适配器、主机总线适配器
	6. 访问磁盘：存储器映射I/O
	7. 商用磁盘剖析
3. 固态硬盘：闪存翻译层
4. 存储技术趋势

局部性：对程序数据引用的局部性、取指令的局部性。

存储器层级结构：寄存器、一级高速缓存、二级高速缓存、三级高速缓存、主存、固态硬盘、本地磁盘、远程存储。

高速缓存：缓存命中、缓存不命中。高速缓存存储器的结构用元组$$(S,E,B,m)$$即（组，行，块，位）描述，高速缓存的大小$$C=S\times E\times B$$。直接映射高速缓存，分为三步：组选择、行匹配、字抽取。书中用一个例子描述了运行中的直接映射高速缓存。组相联高速缓存在书中也给出了详细的描述。

高速缓存的写主要是以写回的方式实现的，即当存储器被更新时才写回下一级缓存。

编写高速缓存友好的代码：让最常见的情况运行得快、让每个循环内部缓存不命中数量最小。

存储器山。

重写排列循环可以提高空间局部性，比如矩阵乘法的最快版本是kij和ikj版本，内循环步增可以最好地提升空间局部性。

# 第二部分 在系统上运行程序

## 第7章 链接

编译程序的基本步骤：

1. `cpp` 预处理器，输出`*.i`
2. `cc1` 编译器，输出`*.s`
3. `as` 汇编器，输出`*.o`
4. `ld` 链接器，输出`a.out`
5. `./a.out` 可执行二进制文件

`ld`是静态链接器，进行符号解析和重定位。

目标文件有三种形式：可重定位目标文件、可执行目标文件、共享目标文件。

Unix可执行和可链接格式（ELF）：

* ELF头
* .text 已编译程序的机器代码
* .rodata 只读数据
* .data 已初始化的全局变量
* .bss 未初始化的全局变量
* .symtab 符号表
* .rel.text 位置引用表
* .rel.data 重定位引用信息
* .debug 调试信息
* .line 行号信息
* .strtab 字符串表

符号和符号表、符号解析。解析多重定义符号，与静态库链接，链接器解析静态库引用。

重定位：重定位条目、重定位符号引用。

可执行目标文件，加载可执行目标文件，动态链接共享库。与位置无关的代码（PIC）。

## 第8章 异常控制流

异常就是控制流中的突变，用来相应处理器状态中的某些变化。

异常包括：中断（interrupt）、陷阱（trap）、故障（fault）、终止（abort）。系统调用是一种陷阱。

进程。逻辑控制流、并发流、私有地址空间、用户模式和内核模式、上下文切换。

进程控制：获取进程编号、创建和终止进程、回收子进程。加载并运行程序。

信号：发送信号、接收信号、信号处理问题、信号阻塞和取消阻塞。

长跳转。

## 第9章 虚拟存储器

# 第三部分 程序间的交互和通信

## 第10章 系统级 I/O

## 第11章 网络编程

## 第12章 并发编程

# 总结
