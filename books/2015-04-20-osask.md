---
layout: page
title: 30天自制操作系统
tagline: 川合秀実
group: book
etitle: "30日でできる！OS自作入門"
permalink: /books/osask/
date: 2015-4-20
update: 2015-6-21
---

书上讲得很细了，我就说说我在制作过程中和书中不一样的做法。

## 第1天 4月20日

写机器码，用的是书中的[Bz编辑器](http://www.vcraft.jp/soft/bz.html)，还是蛮好用的。

写汇编，因为有了[CS:APP](/books/cs-app/)的基础，对于这个自定义的NASK汇编也能很快理解。

## 第2天 4月21日

做启动程序，写了个Makefile。

## 第3天 4月22日

把程序分离开做IPL。读入前几个柱面之后进入32位模式，就可以使用C语言了。这个启动信息的结构体我定义了一个`bootinfo_t`类型来简写，而且以后的结构体都这样简写。

    typedef struct BOOTINFO {
        char cyls, leds, vmode, reserve;
        short scrnx, scrny;
        char *vram;
    } bootinfo_t;

## 第4天 4月23日

加载到图形模式就变得有意思了，首先是颜色，书中给出的16色实在不好看，我就用了编程中常用的[Solarized配色方案](http://ethanschoonover.com/solarized)。到画任务栏的时候，我采取了现在比较流行的扁平化界面。为了画Windows徽标，我又将红黄蓝绿这四个颜色做了微调，于是我们就能看到这个漂亮的四色视窗图标了。另外，黑白两色复原。

    #define base03   0
    #define base02   1
    #define base01   2
    #define base00   3
    #define base0    4
    #define base1    5
    #define base2    6
    #define base3    7
    #define yellow   8
    #define orange   9
    #define red     10
    #define magenta 11
    #define violet  12
    #define blue    13
    #define cyan    14
    #define green   15

    static unsigned char table_rgb[16 * 3] = {
        0x00, 0x00, 0x00, /* base03 */
        0x07, 0x36, 0x42, /* base02 */
        0x58, 0x6e, 0x75, /* base01 */
        0x65, 0x7b, 0x83, /* base00 */
        0x83, 0x94, 0x96, /* base0 */
        0x93, 0xa1, 0xa1, /* base1 */
        0xee, 0xe8, 0xd5, /* base2 */
        0xff, 0xff, 0xff, /* base3 */
        0xfd, 0xb8, 0x13, /* yellow */
        0xcb, 0x4b, 0x16, /* orange */
        0xef, 0x50, 0x26, /* red */
        0xd3, 0x36, 0x82, /* magenta */
        0x6c, 0x71, 0xc4, /* violet */
        0x23, 0x99, 0xd7, /* blue */
        0x2a, 0xa1, 0x98, /* cyan */
        0x7f, 0xbc, 0x43, /* green */
    };

![任务栏](/images/osask/day04_taskbar.png)

## 第5天 4月24日

今天更有意思了，在屏幕上显示鼠标指针和字体。一直以来都觉得书里面给出的指针太难看，就仔细分析了一下Windows 8的鼠标指针形状，将其描绘了出来。注意到这个鼠标指针是19×12大小的，要做相应修改。

    #define CURSOR_X     12
    #define CURSOR_Y     19

    static char cursor[CURSOR_Y][CURSOR_X] = {
        "*           ",
        "**          ",
        "*O*         ",
        "*OO*        ",
        "*OOO*       ",
        "*OOOO*      ",
        "*OOOOO*     ",
        "*OOOOOO*    ",
        "*OOOOOOO*   ",
        "*OOOOOOOO*  ",
        "*OOOOOOOOO* ",
        "*OOOOOOOOOO*",
        "*OOOOOO*****",
        "*OOO*OO*    ",
        "*OO* *OO*   ",
        "*O*  *OO*   ",
        "**    *OO*  ",
        "      *OO*  ",
        "       **   "
    }; /* 仿 Window 8 的鼠标指针 */

这个鼠标指针我觉得还是蛮好看的，虽然在虚拟机里放大了有很明显的锯齿。

关于字体，先开始我直接用了书中给出的字体，这个字体又大又丑（16px），虽然因为懒不想动了但实在是忍不住，上网找个了好看点的点阵字体：[最像素EX2](https://code.google.com/p/zpix)（12px）。这个字体不仅好看，而且包含中日字符，虽然暂时用不到，但是有了一劳永逸的感觉。用FontForge打开这个字体，另外生成一个基于ASCII编码表的Windows FNT字体。算一下，一个字符12px，每行用一个字节表述，就是12字节；一共256个字符，就是256×12=3456字节。可是看了看这个`ZpixEX2-12.fnt`文件是3529字节，多出了73字节，直接载入运行的话果然乱码了。用Bz打开看看，发现头部有一些字体描述信息，所以我尝试找这个偏移量。经过多次试错和计算，终于算出来这个偏移量是45×16=726字符（这里还有问题，在45(0x2D)处实际上是`de.google.com/p/zpix`这个字符串，剩下的二进制数据意义不明。已知用FontForge打开这个文件可以看到在0x20之前没有数据。另外，0x7f-0x9f也没有字形数据，后面的估计也会出错。不过这里我们只用到0x20-0x7e之间的普通字符，暂时还好。），定义成常量。另外也要注意，因为这里变成了12px的字体，所以相应的行高和字宽都要做更改，同样定义成常量。

    #define FNT_H        12
    #define FNT_W         6  // FNT_H / 2
    #define FNT_OFFSET  726  // 65 + 55 * FNT_H + 1

效果还不错，左边的是书中的Haribote-OS ，右边的是我们的。既然看起来还不错，我给它起个名字叫霹雳啪啦操作系统吧（笑）。

![书中的例子](/images/osask/day05_1osask.png)
![指针和字体](/images/osask/day05_2font.png)

## 第6天 4月24日

鼠标不能动，很不爽，于是强行往下做了一天。我们用C语言混着汇编，定义了三个中断的捕获函数。不过只捕获到了键盘中断，鼠标还是没反应。

![键盘中断](/images/osask/day06_int21.png)

## 第7天 4月25日

使用一个FIFO队列缓冲区来获取按键编码，然后我们就可以获取3字节的鼠标数据了。

## 第8天 4月25日

获取鼠标数据后，解析出来移动位置，就可以在屏幕上移动鼠标了。鼠标能动了当然是很高兴，不过明显这个移动逻辑太单纯，以至于把我们可爱的任务栏都擦除了。

![鼠标移动](/images/osask/day08_pointer1.png)
![鼠标移动](/images/osask/day08_pointer2.png)

然后终于把汇编部分讲明白了。

## 第9天 4月26日

检查内存容量，在此基础上实现了一个简单的内存管理，通过管理空闲内存块来分配和释放内存。

## 第10天 4月26日

实现了图层，这样我们的鼠标就可以穿过任务栏而不至于破坏它了。一个小的改动，把`sheet_t`结构体的透明色标识符改成了`alpha`。

![图层](/images/osask/day10_sheet.png)


## 第11天 4月26日

绘制了一个窗口，刚开始我想弄成Windows 8那样的，不过我发现它的边框太大了，就做了一些修改。同样的，关闭按钮也不合适，改。还有窗口标题要居中。嗯，看看这个计数器窗口，是不是有点像Windows 10了。

![窗口](/images/osask/day11_window1.png)
![计数器窗口](/images/osask/day11_window2.png)

这里的“PriPara = Prism Paradise”刚从桌面上了窗口就要说拜拜了，プリパラ=プリティーリズムパラダイス，这就是霹雳啪啦的意思咯。

## 第12天 4月27日

设置多个定时器，计量时间等。主要优化了中断的处理。

## 第13天 4月28日

继续优化定时器，将队列缓冲区扩展到32位，用链表来加快中断处理。

## 第14天 4月28日

我们又在图形界面上取得了重大进展，这是最令人振奋的。首先使用了VBE提高了屏幕分辨率。然后我们捕获了键盘输入，显示在屏幕上，还画了个漂亮的文本框和光标（当然还是仿Windows 8的）。最后，窗口也能移动了，真是太开心了。

![大分辨率](/images/osask/day14_type.png)

## 第15天 4月29日

今天我们加入了多任务，就是时间片分割，保存上下文。

测试速度：QEMU约是4百万，VirtualBox约是4千万。

## 第16天 4月30日

实现了任务管理自动化、任务休眠，并且设定了任务优先级和优先层。

测试速度：QEMU约是8百万，VirtualBox约是7千万。提高了一倍。

![大分辨率](/images/osask/day16_mtask.png)

## 第17天 5月1日

创建了命令行窗口，实现了字符输入，包括大小写字母和符号、锁定键。

![大分辨率](/images/osask/day17_terminal.png)

## 第18天 5月1日

修正了光标闪烁，实现了回车换行和滚屏。

实现了显示内存大小的`mem`，显示目录内容的`dir`命令（别名`ls -l`）、清屏的`cls`命令（别名`clear`）。

## 第19天 5月2日

实现了显示文件内容的`type`（别名`cat`）命令，并支持FAT12文件系统。

这里我把命令行窗口改得更大了，便于显示更多内容。其实现使用了大量常量（改掉了原来的Magic Number）。

## 第20天 5月3日

开始编写应用程序，实现了显示字符和显示字符串的API。

![大分辨率](/images/osask/day21_terminal.png)

## 第21天 5月6日

可以用C编写应用程序了。支持异常。

## 第22天 5月7日

`Ctrl+C`强制结束任务。系统API的增加。

## 第23天 5月10日

malloc的实现。

显示窗口和关闭窗口。

## 第24天 5月13日

使用鼠标切换、移动和关闭窗口。

## 第25天 5月14日

256色。

## 第26天 5月16日~5月19日

多任务内存分配和强制结束。

多个终端和关闭终端。

`open`和`start`启动任务。

## 第27天 5月23日

整理目录结构。分拆API。使用局部段描述符保护程序。

## 第28天 5月24日

alloca的实现和局部大变量。

并不成功地汉字显示——至今没有解决和正在解决……目前是使用了Unifont的16点阵字体，编码使用UTF-8解析。
