---
layout: page
title: 30天自制操作系统
tagline: 川合秀実
group: book
etitle: "30日でできる！OS自作入門"
permalink: /books/osask/
date: 2015-4-20
update: 2015-4-24
---

书上讲得很细了，我就说说我在制作过程中和书中不一样的做法。

## 第1天 4月20日

写机器码，用的是书中的[Bz编辑器](http://www.vcraft.jp/soft/bz.html)，还是蛮好用的。

写汇编，因为有了[CS:APP](/books/cs-app/)的基础，对于这个自定义的NASK汇编也能很快理解。

## 第2天 4月21日

做启动程序，写了个Makefile。

## 第3天 4月22日

把程序分离开做IPL。读入前几个柱面之后进入32位模式，就可以使用C语言了。这个启动信息的结构体我定义了一个`bootinfo_t`类型来简写，而且以后的结构体都这样简写。

    typedef struct BOOTINFO {
        char cyls, leds, vmode, reserve;
        short scrnx, scrny;
        char *vram;
    } bootinfo_t;

## 第4天 4月23日

加载到图形模式就变得有意思了，首先是颜色，书中给出的16色实在不好看，我就用了编程中常用的[Solarized配色方案](http://ethanschoonover.com/solarized)。到画任务栏的时候，我采取了现在比较流行的扁平化界面。为了画Windows徽标，我又将红黄蓝绿这四个颜色做了微调，于是我们就能看到这个漂亮的四色视窗图标了。另外，黑白两色复原。

    #define base03   0
    #define base02   1
    #define base01   2
    #define base00   3
    #define base0    4
    #define base1    5
    #define base2    6
    #define base3    7
    #define yellow   8
    #define orange   9
    #define red     10
    #define magenta 11
    #define violet  12
    #define blue    13
    #define cyan    14
    #define green   15

    static unsigned char table_rgb[16 * 3] = {
        0x00, 0x00, 0x00, /* base03 */
        0x07, 0x36, 0x42, /* base02 */
        0x58, 0x6e, 0x75, /* base01 */
        0x65, 0x7b, 0x83, /* base00 */
        0x83, 0x94, 0x96, /* base0 */
        0x93, 0xa1, 0xa1, /* base1 */
        0xee, 0xe8, 0xd5, /* base2 */
        0xff, 0xff, 0xff, /* base3 */
        0xfd, 0xb8, 0x13, /* yellow */
        0xcb, 0x4b, 0x16, /* orange */
        0xef, 0x50, 0x26, /* red */
        0xd3, 0x36, 0x82, /* magenta */
        0x6c, 0x71, 0xc4, /* violet */
        0x23, 0x99, 0xd7, /* blue */
        0x2a, 0xa1, 0x98, /* cyan */
        0x7f, 0xbc, 0x43, /* green */
    };

![任务栏](/images/osask/day04_taskbar.png)

## 第5天 4月24日

今天更有意思了，在屏幕上显示鼠标指针和字体。一直以来都觉得书里面给出的指针太难看，就仔细分析了一下Windows 8的鼠标指针形状，将其描绘了出来。注意到这个鼠标指针是19×12大小的，要做相应修改。

    #define CURSOR_X     12
    #define CURSOR_Y     19

    static char cursor[CURSOR_Y][CURSOR_X] = {
        "*           ",
        "**          ",
        "*O*         ",
        "*OO*        ",
        "*OOO*       ",
        "*OOOO*      ",
        "*OOOOO*     ",
        "*OOOOOO*    ",
        "*OOOOOOO*   ",
        "*OOOOOOOO*  ",
        "*OOOOOOOOO* ",
        "*OOOOOOOOOO*",
        "*OOOOOO*****",
        "*OOO*OO*    ",
        "*OO* *OO*   ",
        "*O*  *OO*   ",
        "**    *OO*  ",
        "      *OO*  ",
        "       **   "
    }; /* 仿 Window 8 的鼠标指针 */

这个鼠标指针我觉得还是蛮好看的，虽然在虚拟机里放大了有很明显的锯齿（这个图我压缩成320×200了，实际上QEMU中显示的是640×400的放大版）。

![指针](/images/osask/day05_pointer.png)

关于字体，先开始我直接用了书中给出的字体，这个字体又大又丑（16px），虽然因为懒不想动了但实在是忍不住，上网找个了好看点的点阵字体：[最像素EX2](https://code.google.com/p/zpix)（12px）。这个字体不仅好看，而且包含中日字符，虽然暂时用不到，但是有了一劳永逸的感觉。用FontForge打开这个字体，另外生成一个基于ASCII编码表的Windows FNT字体。算一下，一个字符12px，每行用一个字节表述，就是12字节；一共256个字符，就是256×12=3456字节。可是看了看这个`ZpixEX2-12.fnt`文件是3529字节，多出了73字节，直接载入运行的话果然乱码了。用Bz打开看看，发现头部有一些字体描述信息，所以我尝试找这个偏移量。经过多次试错和计算，终于算出来这个偏移量是45×16=726字符（这里还有问题，在45(0x2D)处实际上是`de.google.com/p/zpix`这个字符串，剩下的二进制数据意义不明。已知用FontForge打开这个文件可以看到在0x20之前没有数据。另外，0x7f-0x9f也没有字形数据，后面的估计也会出错。不过这里我们只用到0x20-0x7e之间的普通字符，暂时还好。），定义成常量。另外也要注意，因为这里变成了12px的字体，所以相应的行高和字宽都要做更改，同样定义成常量。

    #define FNT_H        12
    #define FNT_W         6  // FNT_H / 2
    #define FNT_OFFSET  726  // 65 + 55 * FNT_H + 1

效果还不错，就在托盘区加个系统版本好了！

原来的名字 ハリボテOS 也不好听，我就叫它霹雳啪啦（プリパラ）操作系统吧（笑）。

![字体](/images/osask/day05_font.png)

## 第6天 4月24日

鼠标不能动，很不爽，于是强行往下做了一天。我们用C语言混着汇编，定义了三个中断的捕获函数。不过只捕获到了键盘中断，鼠标还是没反应。

![键盘中断](/images/osask/day06_int21.png)

## 第7天 4月25日

使用一个FIFO队列缓冲区来获取按键编码，然后我们就可以获取3字节的鼠标数据了。

## 第8天 4月25日

获取鼠标数据后，解析出来移动位置，就可以在屏幕上移动鼠标了。鼠标能动了当然是很高兴，不过明显这个移动逻辑太单纯，以至于把我们可爱的任务栏都擦除了。

![鼠标移动](/images/osask/day08_pointer1.png)
![鼠标移动](/images/osask/day08_pointer2.png)

然后终于把汇编部分讲明白了。
