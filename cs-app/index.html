<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="《深入理解计算机系统》"><meta name="keywords" content=""><meta name="author" content="原田莓莓,undefined"><meta name="copyright" content="原田莓莓"><title>《深入理解计算机系统》 | 原田莓莓</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.2"><script>var GLOBAL = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  localSearch: undefined
} </script><meta name="generator" content="Hexo 5.3.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="文章详情">站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8"><span class="toc-number">1.</span> <span class="toc-text">第1章 计算机系统漫游</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%E5%92%8C%E6%89%A7%E8%A1%8C"><span class="toc-number"></span> <span class="toc-text">第一部分 程序结构和执行</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">第2章 信息的表示和处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.</span> <span class="toc-text">第3章 程序的机器级表示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.0.1.</span> <span class="toc-text">整数寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8C%87%E7%A4%BA%E7%AC%A6"><span class="toc-number">2.0.2.</span> <span class="toc-text">操作数指示符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E7%A0%81"><span class="toc-number">2.0.3.</span> <span class="toc-text">条件码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4"><span class="toc-number">2.0.4.</span> <span class="toc-text">汇编指令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">第4章 处理器体系结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD"><span class="toc-number">4.</span> <span class="toc-text">第5章 优化程序性能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">5.</span> <span class="toc-text">第6章 存储器层次结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E5%9C%A8%E7%B3%BB%E7%BB%9F%E4%B8%8A%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F"><span class="toc-number"></span> <span class="toc-text">第二部分 在系统上运行程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-%E9%93%BE%E6%8E%A5"><span class="toc-number">1.</span> <span class="toc-text">第7章 链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="toc-number">2.</span> <span class="toc-text">第8章 异常控制流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">第9章 虚拟存储器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E7%A8%8B%E5%BA%8F%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92%E5%92%8C%E9%80%9A%E4%BF%A1"><span class="toc-number"></span> <span class="toc-text">第三部分 程序间的交互和通信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E7%BA%A7-I-O"><span class="toc-number">1.</span> <span class="toc-text">第10章 系统级 I&#x2F;O</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">第11章 网络编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">第12章 并发编程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number"></span> <span class="toc-text">总结</span></a></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/favicon.ico"></div><div class="author-info__name text-center">原田莓莓</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">73</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">34</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">10</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接</div><a class="author-info-links__name text-center" href="https://www.byvoid.com" target="_blank">BYVoid</a><a class="author-info-links__name text-center" href="https://zr.is/" target="_blank">Zeyi Fan</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/images/background/shinohayu1920.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">原田莓莓</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">首页</a><a class="site-page" href="/archives">博文</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/about">关于</a></span></div><div id="post-info"><div id="post-title">《深入理解计算机系统》</div><div id="post-etitle">Computer Systems: A Programmer's Perspective</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2015-03-12</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%80%E6%9B%B8%E7%AD%86%E8%A8%98/">讀書筆記</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/cs-app/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="cs-app/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div id="post-content"><h2 id="第1章-计算机系统漫游"><a href="#第1章-计算机系统漫游" class="headerlink" title="第1章 计算机系统漫游"></a>第1章 计算机系统漫游</h2><p>信息就是 位+上下文。</p>
<p>程序编译的四个阶段：预处理阶段 <code>cpp</code>、编译阶段 <code>cc1</code>、汇编阶段 <code>as</code>、链接阶段 <code>ld</code>。</p>
<p>为何要了解编译系统的工作方式：优化程序性能、理解链接时出现的错误、避免安全漏洞。</p>
<p>系统的硬件组成：总线、I/O 设备、主存、处理器。演示了<code>hello</code>程序的运行过程。</p>
<p>三级高速缓存。存储器层次结构的金字塔。</p>
<p>操作系统管理硬件：进程和线程、虚拟存储器、文件。</p>
<p>并发和并行。</p>
<h1 id="第一部分-程序结构和执行"><a href="#第一部分-程序结构和执行" class="headerlink" title="第一部分 程序结构和执行"></a>第一部分 程序结构和执行</h1><h2 id="第2章-信息的表示和处理"><a href="#第2章-信息的表示和处理" class="headerlink" title="第2章 信息的表示和处理"></a>第2章 信息的表示和处理</h2><p>十六进制表示法，十六进制、二进制、十进制之间的转换。</p>
<p>字和字长、大端法和小端法。</p>
<p>布尔代数，位级运算、逻辑运算、移位运算。</p>
<p>整数的表示法：</p>
<ul>
<li><p>无符号整数 $B2U_w(\vec{x})\doteq\sum_{i=0}^{w-1}{x_i2^i}$</p>
</li>
<li><p>补码 $B2T_w(\vec{x})\doteq -x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}{x_i2^i}$</p>
</li>
<li><p>反码、原码</p>
</li>
<li><p>补码转无符号数：
$T2U_w(x)=\left{\begin{array}{ll}x+2^w,&amp; x&lt;0\x,&amp; x\ge 0\end{array}\right.$</p>
</li>
<li><p>无符号数转补码：
$U2T_w(u)=\left{\begin{array}{ll}u,&amp; u&lt;2^{w-1}\x-2^w,&amp; u\ge 2^{w-1}\end{array}\right.$</p>
</li>
</ul>
<p>C 隐式地将有符号参数强制转换为无符号数并假设其非负来进行计算。</p>
<p>数字的扩展：</p>
<ul>
<li>零扩展</li>
<li>符号扩展：$B2T_{w+k}([x_{w-1},\cdots,x_{w-1},x_{w-1},x_{w-2},\cdots,x_0])=B2T_{w}([x_{w-1},x_{w-2},\cdots,x_0])$</li>
</ul>
<p>数的截断：</p>
<ul>
<li>无符号数的截断：$$B2U_k([x_{k-1},x_{k-2},\cdots,x_0])=B2U_{w}([x_{w-1},x_{w-2},\cdots,x_0])\mod {2^k}$$</li>
<li>有符号数的截断：$$B2T_k([x_{k-1},x_{k-2},\cdots,x_0])=U2T_k(B2U_{w}([x_{w-1},x_{w-2},\cdots,x_0])\mod {2^k})$$</li>
</ul>
<p>整数的运算：</p>
<ul>
<li>无符号加法：$x+^u_w y=\left{\begin{array}{ll}x+y,&amp; x+y&lt;2^w\x+y-2^w,&amp; 2^w\le x+y&lt;2^{w+1}\end{array}\right.$</li>
<li>补码加法：$$x+^t_w y=U2T_w[(x+y)\mod {2^w}]=\left{\begin{array}{lll}
x+y-2^w,&amp; 2^{w-1}\le x+y, &amp; \text{正溢出}\
x+y,&amp; -2^{w-1}\le x+y&lt;2^{w-1},&amp; \text{正常}\
x+y+2^w,&amp; x+y&lt;-2^{w-1}, &amp; \text{负溢出}
\end{array}\right.$$</li>
<li>补码的非：$-^t_w x=\left{\begin{array}{ll}-2^{w-1},&amp; x=-2^{w-1}\-x,&amp; x&gt;-2^{w-1}\end{array}\right.$</li>
<li>无符号乘法：$x*^u_w y=(x\cdot y)\mod {2^w}$</li>
<li>补码乘法：$x*^t_w y=U2T_w((x\cdot y)\mod {2^w})$</li>
<li>乘以常数：$B2U_{w+k}([x_{w-1},x_{w-2},\cdots,x_0,0,\cdots,0])=x2^k$</li>
<li>除以2的幂：$x/2^k=$<code>(x &lt; 0 ? (x + (1 &lt;&lt; k) - 1) : x) &gt;&gt; k</code></li>
</ul>
<p>浮点数：</p>
<ul>
<li>二进制小数（定点小数）</li>
<li>IEEE 浮点小数：规格化的值、非规格化的值、无穷大、NaN。</li>
<li>舍入</li>
<li>浮点运算</li>
</ul>
<h2 id="第3章-程序的机器级表示"><a href="#第3章-程序的机器级表示" class="headerlink" title="第3章 程序的机器级表示"></a>第3章 程序的机器级表示</h2><p>本章主要讲的是 IA32 汇编。在命令行上使用 <code>-S</code> 产生 AT&amp;T 格式的汇编代码：</p>
<pre><code>gcc -O1 -S -m32 &lt;源文件&gt;
</code></pre>
<p>实际的编译代码和书上讲的略有区别，并且不同的优化选项也会产生不同的汇编代码。</p>
<h4 id="整数寄存器"><a href="#整数寄存器" class="headerlink" title="整数寄存器"></a>整数寄存器</h4><table>
<thead>
<tr>
<th>四字寄存器(64位)</th>
<th>双字寄存器(32位)</th>
<th>字寄存器(16位)</th>
<th>高字节寄存器</th>
<th>低字节寄存器</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>63-31</td>
<td>31-15</td>
<td>15-0</td>
<td>15-8</td>
<td>7-0</td>
<td>64位下的作用</td>
</tr>
<tr>
<td>%rax</td>
<td><strong>%eax</strong></td>
<td><strong>%ax</strong></td>
<td><strong>%ah</strong></td>
<td><strong>%al</strong></td>
<td>返回值</td>
</tr>
<tr>
<td>%rbx</td>
<td><strong>%ebx</strong></td>
<td><strong>%bx</strong></td>
<td><strong>%bh</strong></td>
<td><strong>%bl</strong></td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%rcx</td>
<td><strong>%ecx</strong></td>
<td><strong>%cx</strong></td>
<td><strong>%ch</strong></td>
<td><strong>%cl</strong></td>
<td>第4个参数</td>
</tr>
<tr>
<td>%rdx</td>
<td><strong>%edx</strong></td>
<td><strong>%dx</strong></td>
<td><strong>%dh</strong></td>
<td><strong>%dl</strong></td>
<td>第3个参数</td>
</tr>
<tr>
<td>%rsi</td>
<td><strong>%esi</strong></td>
<td><strong>%si</strong></td>
<td></td>
<td>%sil</td>
<td>第2个参数</td>
</tr>
<tr>
<td>%rdi</td>
<td><strong>%edi</strong></td>
<td><strong>%di</strong></td>
<td></td>
<td>%dil</td>
<td>第1个参数</td>
</tr>
<tr>
<td>%rbp</td>
<td><strong>%ebp</strong></td>
<td><strong>%bp</strong></td>
<td></td>
<td>%bpl</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%rsp</td>
<td><strong>%esp</strong></td>
<td><strong>%sp</strong></td>
<td></td>
<td>%spl</td>
<td>栈指针</td>
</tr>
<tr>
<td>%r8</td>
<td>%r8d</td>
<td>%r8w</td>
<td></td>
<td>%r8b</td>
<td>第5个参数</td>
</tr>
<tr>
<td>%r9</td>
<td>%r9d</td>
<td>%r9w</td>
<td></td>
<td>%r9b</td>
<td>第6个参数</td>
</tr>
<tr>
<td>%r10</td>
<td>%r10d</td>
<td>%r10w</td>
<td></td>
<td>%r10b</td>
<td>调用者保存</td>
</tr>
<tr>
<td>%r11</td>
<td>%r11d</td>
<td>%r11w</td>
<td></td>
<td>%r11b</td>
<td>调用者保存</td>
</tr>
<tr>
<td>%r12</td>
<td>%r12d</td>
<td>%r12w</td>
<td></td>
<td>%r12b</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%r13</td>
<td>%r13d</td>
<td>%r13w</td>
<td></td>
<td>%r13b</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%r14</td>
<td>%r14d</td>
<td>%r14w</td>
<td></td>
<td>%r14b</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%r15</td>
<td>%r15d</td>
<td>%r15w</td>
<td></td>
<td>%r15b</td>
<td>被调用者保存</td>
</tr>
</tbody></table>
<h4 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h4><table>
<thead>
<tr>
<th>立即数</th>
<th><code>$Imm</code></th>
<th><code>Imm</code></th>
<th>立即数寻址</th>
</tr>
</thead>
<tbody><tr>
<td>寄存器</td>
<td><code>Ea</code></td>
<td><code>R[Ea]</code></td>
<td>寄存器寻址</td>
</tr>
<tr>
<td>存储器</td>
<td><code>Imm</code></td>
<td><code>M[Imm]</code></td>
<td>绝对寻址</td>
</tr>
<tr>
<td>存储器</td>
<td><code>Imm(Eb,Ei,s)</code></td>
<td><code>M[Imm+R[Eb]+R[Ej]*s]</code></td>
<td>比例变址寻址</td>
</tr>
</tbody></table>
<h4 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h4><table>
<thead>
<tr>
<th><code>CF</code></th>
<th>进位标志</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>ZF</code></td>
<td>零标志</td>
<td></td>
</tr>
<tr>
<td><code>SF</code></td>
<td>符号标志</td>
<td></td>
</tr>
<tr>
<td><code>OF</code></td>
<td>移除标志</td>
<td></td>
</tr>
</tbody></table>
<h4 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h4><table>
<thead>
<tr>
<th>数据传送指令</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>movb S,D</code></td>
<td>传送字节S到D</td>
<td>传送</td>
</tr>
<tr>
<td><code>movw S,D</code></td>
<td>传送字S到D</td>
<td>传送</td>
</tr>
<tr>
<td><code>movl S,D</code></td>
<td>传送双字S到D</td>
<td>传送</td>
</tr>
<tr>
<td><code>movabsq R,I</code></td>
<td>传送立即数I到寄存器R</td>
<td>传送(64位)</td>
</tr>
<tr>
<td><code>movq S,D</code></td>
<td>传送四字S到D</td>
<td>传送(64位)</td>
</tr>
<tr>
<td><code>movsbw S,D</code></td>
<td>传送符号扩展字节S到字D</td>
<td>符号传送</td>
</tr>
<tr>
<td><code>movsbl S,D</code></td>
<td>传送符号扩展字节S到双字D</td>
<td>符号传送</td>
</tr>
<tr>
<td><code>movswl S,D</code></td>
<td>传送符号扩展字S到双字D</td>
<td>符号传送</td>
</tr>
<tr>
<td><code>movsbq S,D</code></td>
<td>传送符号扩展字节S到四字D</td>
<td>符号传送</td>
</tr>
<tr>
<td><code>movswq S,D</code></td>
<td>传送符号扩展字S到四字D</td>
<td>符号传送</td>
</tr>
<tr>
<td><code>movslq S,D</code></td>
<td>传送符号扩展双字S到四字D</td>
<td>符号传送</td>
</tr>
<tr>
<td><code>movzbw S,D</code></td>
<td>传送零扩展字节S到字D</td>
<td>零传送</td>
</tr>
<tr>
<td><code>movzbl S,D</code></td>
<td>传送零扩展字节S到双字D</td>
<td>零传送</td>
</tr>
<tr>
<td><code>movzwl S,D</code></td>
<td>传送零扩展字S到双字D</td>
<td>零传送</td>
</tr>
<tr>
<td><code>movzbq S,D</code></td>
<td>传送零扩展字节S到四字D</td>
<td>零传送(64位)</td>
</tr>
<tr>
<td><code>movzwq S,D</code></td>
<td>传送零扩展字S到四字D</td>
<td>零传送(64位)</td>
</tr>
<tr>
<td><code>movzlq S,D</code></td>
<td>传送零扩展双字S到四字D</td>
<td>零传送(64位)</td>
</tr>
<tr>
<td><code>pushl S</code></td>
<td><code>R[%esp] -= 4;   M[R[%esp]] = S</code></td>
<td>压栈</td>
</tr>
<tr>
<td><code>popl D</code></td>
<td><code>D = M[R[%esp]]; R[%esp] += 4</code></td>
<td>弹栈</td>
</tr>
<tr>
<td><code>pushq S</code></td>
<td><code>R[%rsp] -= 8;   M[R[%rsp]] = S</code></td>
<td>压栈(64位)</td>
</tr>
<tr>
<td><code>popq D</code></td>
<td><code>D = M[R[%rsp]]; R[%rsp] += 8</code></td>
<td>弹栈(64位)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>基本算术操作</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>leal S,D</code></td>
<td><code>D = &amp;S</code></td>
<td>加载有效地址</td>
</tr>
<tr>
<td><code>inc D</code></td>
<td><code>D++</code></td>
<td>递增</td>
</tr>
<tr>
<td><code>dec D</code></td>
<td><code>D--</code></td>
<td>递减</td>
</tr>
<tr>
<td><code>neg D</code></td>
<td><code>D = -D</code></td>
<td>取反</td>
</tr>
<tr>
<td><code>not D</code></td>
<td><code>D = ~D</code></td>
<td>取非</td>
</tr>
<tr>
<td><code>add S,D</code></td>
<td><code>D += S</code></td>
<td>加</td>
</tr>
<tr>
<td><code>sub S,D</code></td>
<td><code>D -= S</code></td>
<td>减</td>
</tr>
<tr>
<td><code>imul S,D</code></td>
<td><code>D *= S</code></td>
<td>乘</td>
</tr>
<tr>
<td><code>xor S,D</code></td>
<td><code>D ^= S</code></td>
<td>异或</td>
</tr>
<tr>
<td><code>or S,D</code></td>
<td><code>D |= S</code></td>
<td>或</td>
</tr>
<tr>
<td><code>and S,D</code></td>
<td><code>D &amp;= S</code></td>
<td>与</td>
</tr>
<tr>
<td><code>sal k,D</code></td>
<td><code>D &lt;&lt;= k</code></td>
<td>左移</td>
</tr>
<tr>
<td><code>shl k,D</code></td>
<td><code>D &lt;&lt;= k</code></td>
<td>左移</td>
</tr>
<tr>
<td><code>sar k,D</code></td>
<td><code>D &gt;&gt;= k</code></td>
<td>算术右移</td>
</tr>
<tr>
<td><code>shr k,D</code></td>
<td><code>D &gt;&gt;&gt;= k</code></td>
<td>逻辑右移</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>特殊算术操作</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>imull S</code></td>
<td><code>R[%edx]:R[%eax] = S * R[%eax]</code></td>
<td>有符号乘法</td>
</tr>
<tr>
<td><code>mull S</code></td>
<td><code>R[%edx]:R[%eax] = S * R[%eax]</code></td>
<td>无符号乘法</td>
</tr>
<tr>
<td><code>cltd</code></td>
<td><code>R[%edx]:R[%eax] = R[%eax]</code></td>
<td>有符号扩展</td>
</tr>
<tr>
<td><code>idivl S</code></td>
<td><code>R[%edx] = R[%edx]:R[%eax] % S</code></td>
<td>有符号除法</td>
</tr>
<tr>
<td></td>
<td><code>R[%eax] = R[%edx]:R[%eax] / S</code></td>
<td></td>
</tr>
<tr>
<td><code>divl S</code></td>
<td><code>R[%edx] = R[%edx]:R[%eax] % S</code></td>
<td>无符号除法</td>
</tr>
<tr>
<td></td>
<td><code>R[%eax] = R[%edx]:R[%eax] / S</code></td>
<td></td>
</tr>
<tr>
<td><code>imulq S</code></td>
<td><code>R[%rdx]:R[%rax] = S * R[%rax]</code></td>
<td>有符号乘法(64位)</td>
</tr>
<tr>
<td><code>mulq S</code></td>
<td><code>R[%rdx]:R[%rax] = S * R[%rax]</code></td>
<td>无符号乘法(64位)</td>
</tr>
<tr>
<td><code>cltdq</code></td>
<td><code>R[%rdx]:R[%rax] = R[%rax]</code></td>
<td>有符号扩展(64位)</td>
</tr>
<tr>
<td><code>idivq S</code></td>
<td><code>R[%rdx] = R[%rdx]:R[%rax] % S</code></td>
<td>有符号除法(64位)</td>
</tr>
<tr>
<td></td>
<td><code>R[%rax] = R[%rdx]:R[%rax] / S</code></td>
<td></td>
</tr>
<tr>
<td><code>divq S</code></td>
<td><code>R[%rdx] = R[%rdx]:R[%rax] % S</code></td>
<td>无符号除法(64位)</td>
</tr>
<tr>
<td></td>
<td><code>R[%rax] = R[%rdx]:R[%rax] / S</code></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>比较和测试指令</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>cmpb S2,S1</code></td>
<td>比较字节 <code>S1 - S2</code></td>
<td>比较</td>
</tr>
<tr>
<td><code>cmpw S2,S1</code></td>
<td>比较单字 <code>S1 - S2</code></td>
<td>比较</td>
</tr>
<tr>
<td><code>cmpl S2,S1</code></td>
<td>比较双字 <code>S1 - S2</code></td>
<td>比较</td>
</tr>
<tr>
<td><code>cmpq S2,S1</code></td>
<td>比较四字 <code>S1 - S2</code></td>
<td>比较(64位)</td>
</tr>
<tr>
<td><code>testb S2,S1</code></td>
<td>测试字节 <code>S1 &amp; S2</code></td>
<td>测试</td>
</tr>
<tr>
<td><code>testw S2,S1</code></td>
<td>测试单字 <code>S1 &amp; S2</code></td>
<td>测试</td>
</tr>
<tr>
<td><code>testl S2,S1</code></td>
<td>测试双字 <code>S1 &amp; S2</code></td>
<td>测试</td>
</tr>
<tr>
<td><code>testq S2,S1</code></td>
<td>测试四字 <code>S1 &amp; S2</code></td>
<td>测试(64位)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>设置条件码</th>
</tr>
</thead>
<tbody><tr>
<td><code>set? D</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>跳转和条件跳转</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>jmp L</code></td>
<td>跳转到标签<code>L</code></td>
<td>直接跳转</td>
</tr>
<tr>
<td><code>jmp *O</code></td>
<td>跳转到<code>*O</code>指向的标签</td>
<td>间接跳转</td>
</tr>
<tr>
<td><code>je L</code> <code>jz L</code></td>
<td><code>ZF</code>为0时跳转</td>
<td>相等跳转</td>
</tr>
<tr>
<td><code>jne L</code> <code>jnz L</code></td>
<td><code>ZF</code>为1时跳转</td>
<td>不相等跳转</td>
</tr>
<tr>
<td><code>js L</code></td>
<td><code>SF</code>为0时跳转</td>
<td>负数跳转</td>
</tr>
<tr>
<td><code>jns L</code></td>
<td><code>SF</code>为1时跳转</td>
<td>非负数跳转</td>
</tr>
<tr>
<td><code>jg L</code> <code>jnle L</code></td>
<td><code>~(SF ^ OF) &amp; ~ZF</code></td>
<td>大于跳转（有符号）</td>
</tr>
<tr>
<td><code>jge L</code> <code>jnl L</code></td>
<td><code>~(SF ^ OF)</code></td>
<td>大于等于跳转（有符号）</td>
</tr>
<tr>
<td><code>jl L</code> <code>jnge L</code></td>
<td><code>SF ^ OF</code></td>
<td>小于跳转（有符号）</td>
</tr>
<tr>
<td><code>jle L</code> <code>jng L</code></td>
<td><code>(SF ^ OF) 1 ZF</code></td>
<td>小于等于跳转（有符号）</td>
</tr>
<tr>
<td><code>ja L</code> <code>jnbe L</code></td>
<td><code>~CF &amp; ~ZF</code></td>
<td>大于跳转（无符号）</td>
</tr>
<tr>
<td><code>jae L</code> <code>jnb L</code></td>
<td><code>~CF</code></td>
<td>大于等于跳转（无符号）</td>
</tr>
<tr>
<td><code>jb L</code> <code>jnae L</code></td>
<td><code>CF ^ OF</code></td>
<td>小于跳转（无符号）</td>
</tr>
<tr>
<td><code>jbe L</code> <code>jna L</code></td>
<td><code>CF 1 ZF</code></td>
<td>小于等于跳转（无符号）</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>条件传送指令</th>
</tr>
</thead>
<tbody><tr>
<td><code>cmov? S,R</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>转移控制</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>call L</code></td>
<td></td>
<td>过程调用</td>
</tr>
<tr>
<td><code>call *O</code></td>
<td></td>
<td>过程调用</td>
</tr>
<tr>
<td><code>leave</code></td>
<td></td>
<td>为返回准备栈</td>
</tr>
<tr>
<td><code>ret</code></td>
<td></td>
<td>返回</td>
</tr>
</tbody></table>
<p>掌握条件语句和循环语句与汇编之间的转换。条件传送指令可以用来优化。switch 语句是用跳转表实现的。注意递归的实现。对数组的访问相当于用指针来访问。结构和联合，以及其他数据都要求对齐以提升性能和适应硬件。</p>
<p>学会使用 GDB 调试器。</p>
<p>理解缓冲区溢出，知道栈随机化、栈破坏检测和限制可执行代码区域的办法。</p>
<p>了解 IA32 汇编和 x86-64 汇编的区别。</p>
<h2 id="第4章-处理器体系结构"><a href="#第4章-处理器体系结构" class="headerlink" title="第4章 处理器体系结构"></a>第4章 处理器体系结构</h2><p>本章定义了一个 Y86 指令集体系结构（ISA），并以此构造出来一个处理器。</p>
<p>简单了解硬件控制语言HCL。</p>
<p>考虑两类存储器设备：存储器（随机访问存储器）和寄存器（时钟寄存器）。寄存器文件有两个读端口（A和B）和一个写端口（W）。</p>
<p>Y86 的顺序实现：取指(Fetch)、译码(Decode)、执行(Execute)、访存(Memory)、写回(Write back)、更新(Program counter update)。要知道每个汇编指令是如何按照这样的顺序在处理器中运行的。以此，实现了顺序实现的 SEQ 硬件。要知道每个过程是怎样以逻辑电路的形式表示的。</p>
<p>为了充分利用硬件单元，引入流水线。计算流水线用吞吐量（单位 GIPS）。流水线的局限性：不一致的划分、流水线过深导致的收益下降。书中实现了重新安排计算阶段设计的带反馈的流水线系统 SEQ+，并在其中插入流水线寄存器得到了 PIPE- 处理器。</p>
<p>流水线冒险是现代处理器的基本处理方式，用暂停、转发可以避免数据冒险。判断预测错误、跳转、返回会导致冒险。</p>
<p>最后实现了 PIPE 处理器，要理解每个阶段的实现。理解流水线控制逻辑和特殊情况的处理。</p>
<p>现代处理器的性能指标为CPI（每指令周期数）的倒数IPC。</p>
<h2 id="第5章-优化程序性能"><a href="#第5章-优化程序性能" class="headerlink" title="第5章 优化程序性能"></a>第5章 优化程序性能</h2><p>编译器优化的能力是有局限性的，编译器必须很小心地对程序只使用安全的优化，必须假设什么情况都有可能发生，不会去试图判断一个函数有没有副作用。</p>
<p>表示程序性能用CPE（每元素周期数）。本章用一个向量加法和乘法的程序来计算不同优化。</p>
<p>有用的优化：消除循环的低效率、减少过程调用、消除不必要的存储器引用。</p>
<p>理解现代处理器，了解处理器的整体操作、功能单元的性能。可以将机器代码转化成数据流图来分析关键路径。</p>
<p>循环展开是一种有效减少循环迭代次数的方法。</p>
<p>提高并行性可以有效提升性能，包括使用多个累积变量、重新结合变换。</p>
<p>一些限制因素：寄存器溢出、分支预测和预测错误处罚。所以不要过分关心可预测的分支，书写适合用条件传送实现的代码。</p>
<p>理解存储器性能。</p>
<p>使用剖析程序 <code>gprof</code> 来分析程序，并利用剖析器来指导优化：</p>
<pre><code>gcc -O1 -pg &lt;source&gt;.c    # 选项 -pg
./a.out                   # 运行后生成 gmon.out 文件
gprof a.out               # 生成分析报告
</code></pre>
<p>Amdahl定律：假设系统某个部分需要占用$\alpha$的时间，而我们将它的性能提高到了$k$倍，则加速比为$$S=\frac{1}{1-\alpha+\frac{\alpha}{k}}$$</p>
<h2 id="第6章-存储器层次结构"><a href="#第6章-存储器层次结构" class="headerlink" title="第6章 存储器层次结构"></a>第6章 存储器层次结构</h2><ol>
<li>随机访问存储器<ol>
<li>SRAM：状态稳定，每个单元用一个六晶体管电路实现</li>
<li>DRAM：对干扰敏感，每个存储器但愿用一个电容和一个访问晶体管组成</li>
<li>传统DRAM：$d\times w, (d=rc)$</li>
<li>存储器模块DIMM和SIMM</li>
<li>增强的DRAM：<ul>
<li>FPM DRAM</li>
<li>EDO DRAM</li>
<li>SDRAM</li>
<li>DDR SDRAM：双倍数据速率同步DRAM，包括DDR、DDR2、DDR3</li>
<li>VRAM</li>
</ul>
</li>
<li>非易失性存储器：<ul>
<li>PROM：可编程ROM，用高电流熔断熔丝来编程</li>
<li>EPROM：可擦写可编程ROM，用紫外线擦写石英窗口</li>
<li>EEPROM：电子可擦写PROM，直接在印制电路卡上编程</li>
<li>闪存/固态硬盘：基于EEPROM</li>
</ul>
</li>
<li>存储器总线：访问主存</li>
</ol>
</li>
<li>磁盘存储<ol>
<li>磁盘构造：盘片、表面、主轴、旋转速率RPM（转每分种）；磁道、扇区、间隙</li>
<li>磁盘容量：记录密度、磁道密度、面密度；多区记录技术 $$磁盘容量=\frac{字节数}{扇区}\times\frac{平均扇区数}{磁道}\times\frac{磁道数}{表面}\times\frac{表面数}{盘片}\times\frac{盘片数}{磁盘}$$</li>
<li>磁盘操作：读写头、传动臂、寻道；寻道时间、旋转时间、传送时间</li>
<li>逻辑磁盘块</li>
<li>链接到I/O设备：通用串行总线（USB）、图形适配器、主机总线适配器</li>
<li>访问磁盘：存储器映射I/O</li>
<li>商用磁盘剖析</li>
</ol>
</li>
<li>固态硬盘：闪存翻译层</li>
<li>存储技术趋势</li>
</ol>
<p>局部性：对程序数据引用的局部性、取指令的局部性。</p>
<p>存储器层级结构：寄存器、一级高速缓存、二级高速缓存、三级高速缓存、主存、固态硬盘、本地磁盘、远程存储。</p>
<p>高速缓存：缓存命中、缓存不命中。高速缓存存储器的结构用元组$(S,E,B,m)$即（组，行，块，位）描述，高速缓存的大小$C=S\times E\times B$。直接映射高速缓存，分为三步：组选择、行匹配、字抽取。书中用一个例子描述了运行中的直接映射高速缓存。组相联高速缓存在书中也给出了详细的描述。</p>
<p>高速缓存的写主要是以写回的方式实现的，即当存储器被更新时才写回下一级缓存。</p>
<p>编写高速缓存友好的代码：让最常见的情况运行得快、让每个循环内部缓存不命中数量最小。</p>
<p>存储器山。</p>
<p>重写排列循环可以提高空间局部性，比如矩阵乘法的最快版本是kij和ikj版本，内循环步增可以最好地提升空间局部性。</p>
<h1 id="第二部分-在系统上运行程序"><a href="#第二部分-在系统上运行程序" class="headerlink" title="第二部分 在系统上运行程序"></a>第二部分 在系统上运行程序</h1><h2 id="第7章-链接"><a href="#第7章-链接" class="headerlink" title="第7章 链接"></a>第7章 链接</h2><p>编译程序的基本步骤：</p>
<ol>
<li><code>cpp</code> 预处理器，输出<code>*.i</code></li>
<li><code>cc1</code> 编译器，输出<code>*.s</code></li>
<li><code>as</code> 汇编器，输出<code>*.o</code></li>
<li><code>ld</code> 链接器，输出<code>a.out</code></li>
<li><code>./a.out</code> 可执行二进制文件</li>
</ol>
<p><code>ld</code>是静态链接器，进行符号解析和重定位。</p>
<p>目标文件有三种形式：可重定位目标文件、可执行目标文件、共享目标文件。</p>
<p>Unix可执行和可链接格式（ELF）：</p>
<ul>
<li>ELF头</li>
<li>.text 已编译程序的机器代码</li>
<li>.rodata 只读数据</li>
<li>.data 已初始化的全局变量</li>
<li>.bss 未初始化的全局变量</li>
<li>.symtab 符号表</li>
<li>.rel.text 位置引用表</li>
<li>.rel.data 重定位引用信息</li>
<li>.debug 调试信息</li>
<li>.line 行号信息</li>
<li>.strtab 字符串表</li>
</ul>
<p>符号和符号表、符号解析。解析多重定义符号，与静态库链接，链接器解析静态库引用。</p>
<p>重定位：重定位条目、重定位符号引用。</p>
<p>可执行目标文件，加载可执行目标文件，动态链接共享库。与位置无关的代码（PIC）。</p>
<h2 id="第8章-异常控制流"><a href="#第8章-异常控制流" class="headerlink" title="第8章 异常控制流"></a>第8章 异常控制流</h2><p>异常就是控制流中的突变，用来相应处理器状态中的某些变化。</p>
<p>异常包括：中断（interrupt）、陷阱（trap）、故障（fault）、终止（abort）。系统调用是一种陷阱。</p>
<p>进程。逻辑控制流、并发流、私有地址空间、用户模式和内核模式、上下文切换。</p>
<p>进程控制：获取进程编号、创建和终止进程、回收子进程。加载并运行程序。</p>
<p>信号：发送信号、接收信号、信号处理问题、信号阻塞和取消阻塞。</p>
<p>长跳转。</p>
<h2 id="第9章-虚拟存储器"><a href="#第9章-虚拟存储器" class="headerlink" title="第9章 虚拟存储器"></a>第9章 虚拟存储器</h2><h1 id="第三部分-程序间的交互和通信"><a href="#第三部分-程序间的交互和通信" class="headerlink" title="第三部分 程序间的交互和通信"></a>第三部分 程序间的交互和通信</h1><h2 id="第10章-系统级-I-O"><a href="#第10章-系统级-I-O" class="headerlink" title="第10章 系统级 I/O"></a>第10章 系统级 I/O</h2><h2 id="第11章-网络编程"><a href="#第11章-网络编程" class="headerlink" title="第11章 网络编程"></a>第11章 网络编程</h2><h2 id="第12章-并发编程"><a href="#第12章-并发编程" class="headerlink" title="第12章 并发编程"></a>第12章 并发编程</h2><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1></div></article><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/talk-about-open-sourse-licenses/"><i class="fa fa-chevron-left">  </i><span>浅谈开源协议</span></a></div><div class="next-post pull-right"><a href="/core-java/"><span>《Java 核心技术》</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var disqus_shortname = 'kingfree'
var disqus_config = function () {
  this.page.url = 'http://blog.kingfree.moe/cs-app/';
  this.page.identifier = 'cs-app/';
  this.page.title = '《深入理解计算机系统》';
}
var d = document, s = d.createElement('script');
s.src = "https://" + disqus_shortname +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-src" src="https://kingfree.disqus.com/count.js" async></script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2008 - 2021 原田莓莓</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.2"></script><script src="/js/fancybox.js?version=1.5.2"></script><script src="/js/sidebar.js?version=1.5.2"></script><script src="/js/copy.js?version=1.5.2"></script><script src="/js/fireworks.js?version=1.5.2"></script><script src="/js/transition.js?version=1.5.2"></script><script src="/js/scroll.js?version=1.5.2"></script><script src="/js/head.js?version=1.5.2"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>