<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Dagger Hashimoto"><meta name="keywords" content="区块链,算法"><meta name="author" content="原田莓莓,undefined"><meta name="copyright" content="原田莓莓"><title>Dagger Hashimoto | 原田莓莓</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.2"><script>var GLOBAL = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  localSearch: undefined
} </script><meta name="generator" content="Hexo 5.3.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="文章详情">站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DAG-%E7%94%9F%E6%88%90"><span class="toc-number">2.</span> <span class="toc-text">DAG 生成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0"><span class="toc-number">2.1.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dagger-%E5%9B%BE%E6%9E%84%E5%BB%BA"><span class="toc-number">2.2.</span> <span class="toc-text">Dagger 图构建</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%AA%8C%E8%AF%81"><span class="toc-number">3.</span> <span class="toc-text">轻量客户端验证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DAG-%E7%9A%84%E5%8F%8C%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">4.</span> <span class="toc-text">DAG 的双缓冲区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hashimoto"><span class="toc-number">5.</span> <span class="toc-text">Hashimoto</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%96%E7%9F%BF%E5%92%8C%E9%AA%8C%E8%AF%81"><span class="toc-number">6.</span> <span class="toc-text">挖矿和验证</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%99%84%E5%BD%95"><span class="toc-number"></span> <span class="toc-text">附录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lehmer-%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">1.</span> <span class="toc-text">Lehmer 随机数生成器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A5%E6%A8%A1%E5%B9%82%E8%BF%90%E7%AE%97%E4%BD%9C%E4%B8%BA%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0"><span class="toc-number">2.</span> <span class="toc-text">以模幂运算作为散列函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E6%9C%89%E6%95%88%E7%9A%84%E5%9F%BA%E4%BA%8E%E7%BC%93%E5%AD%98%E7%9A%84%E9%AA%8C%E8%AF%81%E7%AE%97%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">更有效的基于缓存的验证算法</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/favicon.ico"></div><div class="author-info__name text-center">原田莓莓</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">73</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">34</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">10</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接</div><a class="author-info-links__name text-center" href="https://www.byvoid.com" target="_blank">BYVoid</a><a class="author-info-links__name text-center" href="https://zr.is/" target="_blank">Zeyi Fan</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/images/background/shinohayu1920.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">原田莓莓</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">首页</a><a class="site-page" href="/archives">博文</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/about">关于</a></span></div><div id="post-info"><div id="post-title">Dagger Hashimoto</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-04-24</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E7%BF%BB%E8%AF%91/">翻译</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/dagger-hashimoto/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="dagger-hashimoto/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div id="post-content"><p><em>原文链接：<a target="_blank" rel="noopener" href="https://github.com/ethereum/wiki/blob/master/Dagger-Hashimoto.md">https://github.com/ethereum/wiki/blob/master/Dagger-Hashimoto.md</a></em></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Dagger Hashimoto 是以太坊 1.0 挖矿算法的一个规范。Dagger Hashimoto 目标是实现如下两个目标：</p>
<ol>
<li><strong>反电路特性</strong>: 为算法设计专用硬件的好处应当尽可能地小。理想情况下，相对于使用传统计算机的空闲 CPU 资源挖矿的用户，开发硬件电路的用户也只能有极小的加速效果而缺乏经济效益。</li>
<li><strong>轻量客户端可验证性</strong>: 一个区块应当在轻量客户端上相对的容易进行验证。</li>
</ol>
<p>另外，如果我们需要的话，也定义了如何满足第三个目标，但是相应地也会增加额外的复杂性和花销：
3. <strong>全量链存储</strong>: 矿主应存储整条区块链的状态。（由于以太坊状态树不规则的结构，我们期望有一些可行的剪枝，去最小化某些常用的合约操作）</p>
<p>Dagger Hashimoto 建立在之前两个关键的工作之上：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://vaurum.com/hashimoto.pdf">Hashimoto</a> 是由 Thaddeus Dryja 设计的通过限制输入输出以达成反电路特性的算法，比如在挖矿进程中限制内存读取的因子。理论是，RAM 原则上是一种比计算更通用的成分，并且已经有数十亿美元的研究试图对不同的近乎随机访问模式的（由于“随机内存访问”）用例对它进行优化；因此，现有的 RAM 在评估算法时已较接近最优。Hashimoto 使用区块链作为来源数据，同时满足了上面的 (1) 和 (3)。</li>
<li><a target="_blank" rel="noopener" href="http://vitalik.ca/ethereum/dagger.html">Dagger</a> 是由 Vitalik Buterin 设计的用于在有向无环图（DAG）上实现计算上对内存难但验证对内存易的算法。核心理念是每个单独的 nonce 只需要一大棵数据树的一小部分，并且禁止矿主重新计算每个 nonce 对应的子树——因此需要存储整棵树——但是允许对单独的 nonce 进行验证。Dagger 意义在于指出了存在一种类似于 <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Scrypt">Scrypt</a> 的对内存难算法，不仅对内存难，而且对当内存难度增加到真正安程度的验证也非常难。然而，Dagger 已经被 <a target="_blank" rel="noopener" href="https://bitslog.wordpress.com/2014/01/17/ethereum-dagger-pow-is-flawed/">Sergio Lerner</a> 证明容易受到共享内存硬件加速的影响，并转而支持其他途径的研究去了。</li>
</ul>
<p>在 Dagger 和 Dagger Hashimoto 之间的处理不是我们本次关注的重点，包括：</p>
<ul>
<li>“基于区块链的工作证明”——一种为区块链上运行的合约证明工作的方法。因为它有受到溢出攻击的漏洞所以被废弃了，攻击者可以创建分支并且用它们有的一种机密的快速“trapdoor”执行机制的合约填充来它们。</li>
<li>“随机电路”——一个由 Vlad Zamfir 开发的工作证明算法，通过对每 1000 个 nonce 生成一段新程序实现——本质上，每次选择一个新的散列算法是比重新配置 FPGA 更快。这种算法被搁置的原因在于很难看出人们可以用什么机制来产生随机的程序，这使得专门化的收益降低；然而，我们没有看到为什么这个概念不能实现的根本原因。</li>
</ul>
<p>Dagger Hashimoto 和 Hashimoto 的区别在于，Dagger Hashimoto 没有使用区块链作为数据源，而是使用了一个自定义生成的 1GB 数据集，该数据集根据每 N 块的块数据进行更新。该数据集是使用 Dagger算法生成的，允许对每个 nonce 进行有效计算，用于轻客户端验证算法。Dagger Hashimoto 和 Dagger 的区别还在于，与原来的 Dagger 不同，用于查询块的数据集是半永久性的，只是偶尔更新（比如每周一次）。这意味着用于生成数据集的部分工作接近于零，因此 Sergio Lerner 关于共享内存速度的争论变得微不足道了。</p>
<h2 id="DAG-生成"><a href="#DAG-生成" class="headerlink" title="DAG 生成"></a>DAG 生成</h2><p>算法定义在下面的 Python 代码中。首先，我们给出 <code>encode_int</code>，用于将指定精度的非负整数转为字符串。它的逆算法也给出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">NUM_BITS = <span class="number">512</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode_int</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="string">&quot;将整数 x 编码为 64 字符的大端序格式&quot;</span></span><br><span class="line">    o = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(NUM_BITS / <span class="number">8</span>):</span><br><span class="line">        o = <span class="built_in">chr</span>(x % <span class="number">256</span>) + o</span><br><span class="line">        x //= <span class="number">256</span></span><br><span class="line">    <span class="keyword">return</span> o</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode_int</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="string">&quot;从大端序字符串解码为整数 x&quot;</span></span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        x *= <span class="number">256</span></span><br><span class="line">        x += <span class="built_in">ord</span>(c)</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<p><code>sha3</code> 接收一个整数并输出一个整数，而 <code>dbl_sha3</code> 则运行了两遍 <code>sha3</code>；代码实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyethereum <span class="keyword">import</span> utils</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sha3</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(x, (<span class="built_in">int</span>, long)):</span><br><span class="line">        x = encode_int(x)</span><br><span class="line">    <span class="keyword">return</span> decode_int(utils.sha3(x))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dbl_sha3</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(x, (<span class="built_in">int</span>, long)):</span><br><span class="line">        x = encode_int(x)</span><br><span class="line">    <span class="keyword">return</span> decode_int(utils.sha3(utils.sha3(x)))    </span><br></pre></td></tr></table></figure>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>算法需要的参数如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SAFE_PRIME_512 = <span class="number">2</span>**<span class="number">512</span> - <span class="number">38117</span>     <span class="comment"># 小于 2**512 的最大安全素数</span></span><br><span class="line"></span><br><span class="line">params = &#123;</span><br><span class="line">      <span class="string">&quot;n&quot;</span>: <span class="number">4000055296</span> * <span class="number">8</span> // NUM_BITS,  <span class="comment"># 数据集大小（4 GB）；必须是 65536 的倍数</span></span><br><span class="line">      <span class="string">&quot;n_inc&quot;</span>: <span class="number">65536</span>,                   <span class="comment"># 每 n 个周期增长的值；必须是 65536 的倍数</span></span><br><span class="line">                                        <span class="comment"># 并且每年当 epochtime=20000 时增加 882 MB </span></span><br><span class="line">      <span class="string">&quot;cache_size&quot;</span>: <span class="number">2500</span>,               <span class="comment"># 轻客户端缓存大小（由客户端决定；非算法一部分）</span></span><br><span class="line">      <span class="string">&quot;diff&quot;</span>: <span class="number">2</span>**<span class="number">14</span>,                    <span class="comment"># 难度（适用于块验证）</span></span><br><span class="line">      <span class="string">&quot;epochtime&quot;</span>: <span class="number">100000</span>,              <span class="comment"># 块中每世代长度（数据集更新频率）</span></span><br><span class="line">      <span class="string">&quot;k&quot;</span>: <span class="number">1</span>,                           <span class="comment"># 结点的父结点数量</span></span><br><span class="line">      <span class="string">&quot;w&quot;</span>: w,                           <span class="comment"># 用于模幂运算散列</span></span><br><span class="line">      <span class="string">&quot;accesses&quot;</span>: <span class="number">200</span>,                  <span class="comment"># Hashimoto 时访问数据集的次数</span></span><br><span class="line">      <span class="string">&quot;P&quot;</span>: SAFE_PRIME_512               <span class="comment"># 用于散列和随机数生成的安全素数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>P</code> 是一个素数并满足 <code>log₂(P)</code> 略小于 512，以对应我们使用的 512 位表示的数字。注意实际上只需要存储 DAG 的后半部分，因为从 1 GB 开始的每年的内存增长就会是 441 MB。</p>
<h3 id="Dagger-图构建"><a href="#Dagger-图构建" class="headerlink" title="Dagger 图构建"></a>Dagger 图构建</h3><p>有向图的建立过程如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">produce_dag</span>(<span class="params">params, seed, length</span>):</span></span><br><span class="line">    P = params[<span class="string">&quot;P&quot;</span>]</span><br><span class="line">    picker = init = <span class="built_in">pow</span>(sha3(seed), params[<span class="string">&quot;w&quot;</span>], P)</span><br><span class="line">    o = [init]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, length):</span><br><span class="line">        x = picker = (picker * init) % P</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(params[<span class="string">&quot;k&quot;</span>]):</span><br><span class="line">            x ^= o[x % i]</span><br><span class="line">        o.append(<span class="built_in">pow</span>(x, params[<span class="string">&quot;w&quot;</span>], P))</span><br><span class="line">    <span class="keyword">return</span> o</span><br></pre></td></tr></table></figure>
<p>算法从某个随机结点开始计算 <code>sha3(seed)</code>，在此之上依次添加其他结点。创建新结点时，会随机对小于 <code>i</code> 的来计算种子的模幂（用上面的 <code>x % i</code>），结点值还用于计算 <code>x</code>，然后用基于 XOR 的证明算法来生成 <code>i</code> 上的 <code>x</code>。该算法要求 DAG 是可以顺序访问的，并且只能在已知当前结点时才能访问下一个结点。最后，用模幂运算计算散列值。</p>
<p>算法依赖于附录描述的几个数论方面的结论。</p>
<h2 id="轻量客户端验证"><a href="#轻量客户端验证" class="headerlink" title="轻量客户端验证"></a>轻量客户端验证</h2><p>上述图构造的目的是通过计算仅有少量节点的子树并仅需要少量辅助存储器来重构图中的每个单独节点。注意当 k=1 时，子树仅是 DAG 首个元素后的一条链。</p>
<p>DAG 上的轻客户端计算方法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_calc</span>(<span class="params">params, seed, p</span>):</span></span><br><span class="line">    w, P = params[<span class="string">&quot;w&quot;</span>], params[<span class="string">&quot;P&quot;</span>]</span><br><span class="line">    cache = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quick_calc_cached</span>(<span class="params">p</span>):</span></span><br><span class="line">        <span class="keyword">if</span> p <span class="keyword">in</span> cache:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">elif</span> p == <span class="number">0</span>:</span><br><span class="line">            cache[p] = <span class="built_in">pow</span>(sha3(seed), w, P)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            x = <span class="built_in">pow</span>(sha3(seed), (p + <span class="number">1</span>) * w, P)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(params[<span class="string">&quot;k&quot;</span>]):</span><br><span class="line">                x ^= quick_calc_cached(x % p)</span><br><span class="line">            cache[p] = <span class="built_in">pow</span>(x, w, P)</span><br><span class="line">        <span class="keyword">return</span> cache[p]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> quick_calc_cached(p)</span><br></pre></td></tr></table></figure>
<p>本质上，这只是对上面算法的一种简写，其中删除了计算整个 DAG 值的循环，并利用记忆化递归实现结点查找。注意，k=1 时不需要缓存，进一步的优化会预先计算出 DAG 的前几千个值并缓存。请参阅附录中的实现。</p>
<h2 id="DAG-的双缓冲区"><a href="#DAG-的双缓冲区" class="headerlink" title="DAG 的双缓冲区"></a>DAG 的双缓冲区</h2><p>In a full client, a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Multiple_buffering"><em>double buffer</em></a> of 2 DAGs produced by the above formula is used.  The idea is that DAGs are produced every <code>epochtime</code> number of blocks according to the params above.  The client does not use the latest DAG produced, but the previous one. The benefit of this is that it allows the DAGs to be replaced over time without needing to incorporate a step where miners must suddenly recompute all of the data. Otherwise, there is the potential for an abrupt temporary slowdown in chain processing at regular intervals and dramatically increasing centralization and thus 51% attack risks within those few minutes before all data is recomputed.</p>
<p>The algorithm used to generate the actual set of DAGs used to compute the work for a block is as follows:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_prevhash</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">from</span> pyethereum.blocks <span class="keyword">import</span> GENESIS_PREVHASH </span><br><span class="line">    <span class="keyword">from</span> pyethreum <span class="keyword">import</span> chain_manager</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> hash_to_int(GENESIS_PREVHASH)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        prevhash = chain_manager.index.get_block_by_number(n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> decode_int(prevhash)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_seedset</span>(<span class="params">params, block</span>):</span></span><br><span class="line">    seedset = &#123;&#125;</span><br><span class="line">    seedset[<span class="string">&quot;back_number&quot;</span>] = block.number - (block.number % params[<span class="string">&quot;epochtime&quot;</span>])</span><br><span class="line">    seedset[<span class="string">&quot;back_hash&quot;</span>] = get_prevhash(seedset[<span class="string">&quot;back_number&quot;</span>])</span><br><span class="line">    seedset[<span class="string">&quot;front_number&quot;</span>] = <span class="built_in">max</span>(seedset[<span class="string">&quot;back_number&quot;</span>] - params[<span class="string">&quot;epochtime&quot;</span>], <span class="number">0</span>)</span><br><span class="line">    seedset[<span class="string">&quot;front_hash&quot;</span>] = get_prevhash(seedset[<span class="string">&quot;front_number&quot;</span>])</span><br><span class="line">    <span class="keyword">return</span> seedset</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_dagsize</span>(<span class="params">params, block</span>):</span></span><br><span class="line">    <span class="keyword">return</span> params[<span class="string">&quot;n&quot;</span>] + (block.number // params[<span class="string">&quot;epochtime&quot;</span>]) * params[<span class="string">&quot;n_inc&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_daggerset</span>(<span class="params">params, block</span>):</span></span><br><span class="line">    dagsz = get_dagsize(params, block)</span><br><span class="line">    seedset = get_seedset(params, block)</span><br><span class="line">    <span class="keyword">if</span> seedset[<span class="string">&quot;front_hash&quot;</span>] &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># No back buffer is possible, just make front buffer</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;front&quot;</span>: &#123;<span class="string">&quot;dag&quot;</span>: produce_dag(params, seedset[<span class="string">&quot;front_hash&quot;</span>], dagsz), </span><br><span class="line">                          <span class="string">&quot;block_number&quot;</span>: <span class="number">0</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;front&quot;</span>: &#123;<span class="string">&quot;dag&quot;</span>: produce_dag(params, seedset[<span class="string">&quot;front_hash&quot;</span>], dagsz),</span><br><span class="line">                          <span class="string">&quot;block_number&quot;</span>: seedset[<span class="string">&quot;front_number&quot;</span>]&#125;,</span><br><span class="line">                <span class="string">&quot;back&quot;</span>: &#123;<span class="string">&quot;dag&quot;</span>: produce_dag(params, seedset[<span class="string">&quot;back_hash&quot;</span>], dagsz),</span><br><span class="line">                         <span class="string">&quot;block_number&quot;</span>: seedset[<span class="string">&quot;back_number&quot;</span>]&#125;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Hashimoto"><a href="#Hashimoto" class="headerlink" title="Hashimoto"></a>Hashimoto</h2><p>The idea behind the original Hashimoto is to use the blockchain as a dataset, performing a computation which selects N indices from the blockchain, gathers the transactions at those indices, performs an XOR of this data, and returns the hash of the result. Thaddeus Dryja’s original algorithm, translated to Python for consistency, is as follows:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">orig_hashimoto</span>(<span class="params">prev_hash, merkle_root, list_of_transactions, nonce</span>):</span></span><br><span class="line">    hash_output_A = sha256(prev_hash + merkle_root + nonce) </span><br><span class="line">    txid_mix = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">64</span>):</span><br><span class="line">        shifted_A = hash_output_A &gt;&gt; i </span><br><span class="line">        transaction = shifted_A % <span class="built_in">len</span>(list_of_transactions) </span><br><span class="line">        txid_mix ^= list_of_transactions[transaction] &lt;&lt; i </span><br><span class="line">    <span class="keyword">return</span> txid_max ^ (nonce &lt;&lt; <span class="number">192</span>)</span><br></pre></td></tr></table></figure>
<p>Unfortunately, while Hashimoto is considered RAM hard, it relies on 256-bit arithmetic, which has considerable computational overhead. To address this issue, dagger hashimoto only uses the least significant 64 bits when indexing its dataset.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hashimoto</span>(<span class="params">dag, dagsize, params, header, nonce</span>):</span></span><br><span class="line">    m = dagsize / <span class="number">2</span></span><br><span class="line">    mix = sha3(encode_int(nonce) + header)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(params[<span class="string">&quot;accesses&quot;</span>]):</span><br><span class="line">        mix ^= dag[m + (mix % <span class="number">2</span>**<span class="number">64</span>) % m]</span><br><span class="line">    <span class="keyword">return</span> dbl_sha3(mix)</span><br></pre></td></tr></table></figure>
<p>The use of double sha3 allows for a form of zero-data, near-instant pre-verification, verifying only that a correct intermediate value was provided. This outer layer of PoW is highly ASIC-friendly and fairly weak, but exists to make DDoS even more difficult since that small amount of work must be done in order to produce a block that will not be rejected immediately. Here is the light-client version:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_hashimoto</span>(<span class="params">seed, dagsize, params, header, nonce</span>):</span></span><br><span class="line">    m = dagsize // <span class="number">2</span></span><br><span class="line">    mix = sha3(nonce + header)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(params[<span class="string">&quot;accesses&quot;</span>]):</span><br><span class="line">        mix ^= quick_calc(params, seed, m + (mix % <span class="number">2</span>**<span class="number">64</span>) % m)</span><br><span class="line">    <span class="keyword">return</span> dbl_sha3(mix)</span><br></pre></td></tr></table></figure>
<h2 id="挖矿和验证"><a href="#挖矿和验证" class="headerlink" title="挖矿和验证"></a>挖矿和验证</h2><p>Now, let us put it all together into the mining algo:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mine</span>(<span class="params">daggerset, params, block</span>):</span></span><br><span class="line">    <span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line">    nonce = randint(<span class="number">0</span>, <span class="number">2</span>**<span class="number">64</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        result = hashimoto(daggerset, get_dagsize(params, block),</span><br><span class="line">                           params, decode_int(block.prevhash), nonce)</span><br><span class="line">        <span class="keyword">if</span> result * params[<span class="string">&quot;diff&quot;</span>] &lt; <span class="number">2</span>**<span class="number">256</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        nonce += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nonce &gt;= <span class="number">2</span>**<span class="number">64</span>:</span><br><span class="line">            nonce = <span class="number">0</span> </span><br><span class="line">    <span class="keyword">return</span> nonce</span><br></pre></td></tr></table></figure>
<p>Here is the verification algorithm:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verify</span>(<span class="params">daggerset, params, block, nonce</span>):</span></span><br><span class="line">    result = hashimoto(daggerset, get_dagsize(params, block),</span><br><span class="line">                       params, decode_int(block.prevhash), nonce)</span><br><span class="line">    <span class="keyword">return</span> result * params[<span class="string">&quot;diff&quot;</span>] &lt; <span class="number">2</span>**<span class="number">256</span></span><br></pre></td></tr></table></figure>
<p>Light-client friendly verification:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">light_verify</span>(<span class="params">params, header, nonce</span>):</span></span><br><span class="line">    seedset = get_seedset(params, block)</span><br><span class="line">    result = quick_hashimoto(seedset[<span class="string">&quot;front_hash&quot;</span>], get_dagsize(params, block),</span><br><span class="line">                             params, decode_int(block.prevhash), nonce)</span><br><span class="line">    <span class="keyword">return</span> result * params[<span class="string">&quot;diff&quot;</span>] &lt; <span class="number">2</span>**<span class="number">256</span></span><br></pre></td></tr></table></figure>
<p>Also, note that Dagger Hashimoto imposes additional requirements on the block header:</p>
<ul>
<li>For two-layer verification to work, a block header must have both the nonce and the middle value pre-sha3</li>
<li>Somewhere, a block header must store the sha3 of the current seedset</li>
</ul>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>As noted above, the RNG used for DAG generation relies on some results from number theory. First, we provide assurance that the Lehmer RNG that is the basis for the <code>picker</code> variable has a wide period.  Second, we show that <code>pow(x,3,P)</code> will not map <code>x</code> to <code>1</code> or <code>P-1</code> provided <code>x ∈ [2,P-2]</code> to start.  Finally, we show that <code>pow(x,3,P)</code> has a low collision rate when treated as a hashing function.</p>
<h2 id="Lehmer-随机数生成器"><a href="#Lehmer-随机数生成器" class="headerlink" title="Lehmer 随机数生成器"></a>Lehmer 随机数生成器</h2><p>While the <code>produce_dag</code> function does not need to produce unbiased random numbers, a potential threat is that <code>seed**i % P</code> only takes on a handful of values. This could provide an advantage to miners recognizing the pattern over those that do not.</p>
<p>To avoid this, a result from number theory is appealed to. A <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Safe_prime"><em>Safe Prime</em></a> is defined to be a prime <code>P</code> such that <code>(P-1)/2</code> is also prime.  The <em>order</em> of a member <code>x</code> of the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Multiplicative_group_of_integers_modulo_n">multiplicative group</a> <code>ℤ/nℤ</code> is defined to be the minimal <code>m</code> such that <center><pre>xᵐ mod P ≡ 1</pre></center>
Given these definitions, we have:</p>
<blockquote>
<p>Observation 1. Let <code>x</code> be a member of the multiplicative group <code>ℤ/Pℤ</code> for a safe prime <code>P</code>.  If <code>x mod P ≠ 1 mod P</code> and <code>x mod P ≠ P-1 mod P</code>, then the order of <code>x</code> is either <code>P-1</code> or <code>(P-1)/2</code>.</p>
</blockquote>
<p><em>Proof</em>.  Since <code>P</code> is a safe prime, then by <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Lagrange%27s_theorem_(group_theory)">Lagrange’s Theorem</a> we have that the order of <code>x</code> is either <code>1</code>, <code>2</code>, <code>(P-1)/2</code>, or <code>P-1</code>.</p>
<p>The order of <code>x</code> cannot be <code>1</code>, since by Fermat’s Little Theorem we have:</p>
<center><pre>x<sup>P-1</sup> mod P ≡ 1</pre></center>
Hence `x` must be a multiplicative identity of `ℤ/nℤ`, which is unique.  Since we assumed that `x ≠ 1` by assumption, this is not possible.

<p>The order of <code>x</code> cannot be <code>2</code> unless <code>x = P-1</code>, since this would violate that <code>P</code> is prime.</p>
<div align="right">◻</div>

<p>From the above proposition, we can recognize that iterating <code>(picker * init) % P</code> will have a cycle length of at least <code>(P-1)/2</code>.  This is because we selected <code>P</code> to be a safe prime approximately equal to be a higher power of two, and <code>init</code> is in the interval <code>[2,2**256+1]</code>.  Given the magnitude fo <code>P</code>, we should never expect a cycle from modular exponentiation.</p>
<p>When we are assigning the first cell in the DAG (the variable labeled <code>init</code>), we compute <code>pow(sha3(seed) + 2, 3, P)</code>.  At first glance, this does not guarantee that the result is neither <code>1</code> nor <code>P-1</code>.  However, since <code>P-1</code> is a safe prime, we have the following additional assuance, which is a corollary of Observation 1:</p>
<blockquote>
<p>Observation 2. Let <code>x</code> be a member of the multiplicative group <code>ℤ/Pℤ</code> for a safe prime <code>P</code>, and let <code>w</code> be a natural number. If <code>x mod P ≠ 1 mod P</code> and <code>x mod P ≠ P-1 mod P</code>, as well as <code>w mod P ≠ P-1 mod P</code> and <code>w mod P ≠ 0 mod P</code>, then <code>xʷ mod P ≠ 1 mod P</code> and <code>xʷ mod P ≠ P-1 mod P</code></p>
</blockquote>
<h2 id="以模幂运算作为散列函数"><a href="#以模幂运算作为散列函数" class="headerlink" title="以模幂运算作为散列函数"></a>以模幂运算作为散列函数</h2><p>For certain values of <code>P</code> and <code>w</code>, the function <code>pow(x, w, P)</code> may have many collisions.  For instance, <code>pow(x,9,19)</code> only takes on values <code>&#123;1,18&#125;</code>. </p>
<p>Given that <code>P</code> is prime, then an appropriate <code>w</code> for a modular exponentation hashing function can be chosen using the following result:</p>
<blockquote>
<p>Observation 3. Let <code>P</code> be a prime; <code>w</code> and <code>P-1</code> are relatively prime if and only if for all <code>a</code> and <code>b</code> in <code>ℤ/Pℤ</code>:<center><code>aʷ mod P ≡ bʷ mod P</code> if and only if <code>a mod P ≡ b mod P</code></center></p>
</blockquote>
<p>Thus, given that <code>P</code> is prime and <code>w</code> is relatively prime to <code>P-1</code>, we have that <code>|&#123;pow(x, w, P) : x ∈ ℤ&#125;| = P</code>, implying that the hashing function has the minimal collision rate possible.</p>
<p>In the special case that <code>P</code> is a safe prime as we have selected, then <code>P-1</code> only has factors 1, 2, <code>(P-1)/2</code> and <code>P-1</code>.  Since <code>P</code> &gt; 7, we know that 3 is relatively prime to <code>P-1</code>, hence <code>w=3</code> satisfies the above proposition.</p>
<h2 id="更有效的基于缓存的验证算法"><a href="#更有效的基于缓存的验证算法" class="headerlink" title="更有效的基于缓存的验证算法"></a>更有效的基于缓存的验证算法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_calc</span>(<span class="params">params, seed, p</span>):</span></span><br><span class="line">    cache = produce_dag(params, seed, params[<span class="string">&quot;cache_size&quot;</span>])</span><br><span class="line">    <span class="keyword">return</span> quick_calc_cached(cache, params, p)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_calc_cached</span>(<span class="params">cache, params, p</span>):</span></span><br><span class="line">    P = params[<span class="string">&quot;P&quot;</span>]</span><br><span class="line">    <span class="keyword">if</span> p &lt; <span class="built_in">len</span>(cache):</span><br><span class="line">        <span class="keyword">return</span> cache[p]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x = <span class="built_in">pow</span>(cache[<span class="number">0</span>], p + <span class="number">1</span>, P)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(params[<span class="string">&quot;k&quot;</span>]):</span><br><span class="line">            x ^= quick_calc_cached(cache, params, x % p)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(x, params[<span class="string">&quot;w&quot;</span>], P)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_hashimoto</span>(<span class="params">seed, dagsize, params, header, nonce</span>):</span></span><br><span class="line">    cache = produce_dag(params, seed, params[<span class="string">&quot;cache_size&quot;</span>])</span><br><span class="line">    <span class="keyword">return</span> quick_hashimoto_cached(cache, dagsize, params, header, nonce)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_hashimoto_cached</span>(<span class="params">cache, dagsize, params, header, nonce</span>):</span></span><br><span class="line">    m = dagsize // <span class="number">2</span></span><br><span class="line">    mask = <span class="number">2</span>**<span class="number">64</span> - <span class="number">1</span></span><br><span class="line">    mix = sha3(encode_int(nonce) + header)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(params[<span class="string">&quot;accesses&quot;</span>]):</span><br><span class="line">        mix ^= quick_calc_cached(cache, params, m + (mix &amp; mask) % m)</span><br><span class="line">    <span class="keyword">return</span> dbl_sha3(mix)</span><br></pre></td></tr></table></figure>
<hr>
<p>感谢下面的反馈：</p>
<ul>
<li>Tim Hughes</li>
<li>Matthew Wampler-Doty</li>
<li>Thaddeus Dryja</li>
</ul>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/install-bitcoin/"><i class="fa fa-chevron-left">  </i><span>比特币Bitcoin源代码安装编译【转】</span></a></div><div class="next-post pull-right"><a href="/ethash-algorithm/"><span>Ethash 算法</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var disqus_shortname = 'kingfree'
var disqus_config = function () {
  this.page.url = 'http://blog.kingfree.moe/dagger-hashimoto/';
  this.page.identifier = 'dagger-hashimoto/';
  this.page.title = 'Dagger Hashimoto';
}
var d = document, s = d.createElement('script');
s.src = "https://" + disqus_shortname +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-src" src="https://kingfree.disqus.com/count.js" async></script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2008 - 2021 原田莓莓</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.2"></script><script src="/js/fancybox.js?version=1.5.2"></script><script src="/js/sidebar.js?version=1.5.2"></script><script src="/js/copy.js?version=1.5.2"></script><script src="/js/fireworks.js?version=1.5.2"></script><script src="/js/transition.js?version=1.5.2"></script><script src="/js/scroll.js?version=1.5.2"></script><script src="/js/head.js?version=1.5.2"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>